
@article{silverman_rich_2012,
	title = {Rich socio-cognitive agents for immersive training environments: case of {NonKin} {Village}},
	volume = {24},
	journal = {Autonomous Agents and Multi-Agent Systems},
	author = {Silverman, Barry G and Pietrocola, David and Nye, Ben and Weyer, Nathan and Osin, Oleg and Johnson, Dan and Weaver, Ransom},
	year = {2012},
	note = {Publisher: Springer US},
	pages = {312--343},
}

@article{dignum_relational_2022,
	title = {Relational artificial intelligence},
	journal = {arXiv preprint arXiv:2202.07446},
	author = {Dignum, Virginia},
	year = {2022},
}

@article{lorenzen_reference_2022,
	title = {Reference counting with frame limited reuse},
	volume = {6},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Lorenzen, Anton and Leijen, Daan},
	year = {2022},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {357--380},
	file = {Lorenzen and Leijen - 2022 - Reference counting with frame limited reuse.pdf:/Users/timwhiting/Zotero/storage/3MKH4MGE/Lorenzen and Leijen - 2022 - Reference counting with frame limited reuse.pdf:application/pdf},
}

@inproceedings{reinking_perceus_2021,
	title = {Perceus: {Garbage} free reference counting with reuse},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	author = {Reinking, Alex and Xie, Ningning and de Moura, Leonardo and Leijen, Daan},
	year = {2021},
	keywords = {to-read},
	pages = {96--111},
	file = {Reinking et al_2021_Perceus.pdf:/Users/timwhiting/Zotero/storage/X3G5MLZS/Reinking et al_2021_Perceus.pdf:application/pdf;Reinking et al_2021_Perceus2.pdf:/Users/timwhiting/Zotero/storage/E3IHWH7I/Reinking et al_2021_Perceus2.pdf:application/pdf},
}

@inproceedings{bowling_rational_2001,
	title = {Rational and convergent learning in stochastic games},
	volume = {17},
	booktitle = {International joint conference on artificial intelligence},
	publisher = {Citeseer},
	author = {Bowling, Michael and Veloso, Manuela},
	year = {2001},
	note = {Issue: 1},
	pages = {1021--1026},
}

@article{powers_new_2004,
	title = {New criteria and a new algorithm for learning in multi-agent systems},
	volume = {17},
	journal = {Advances in neural information processing systems},
	author = {Powers, Rob and Shoham, Yoav},
	year = {2004},
}

@article{bowling_multiagent_2002,
	title = {Multiagent learning using a variable learning rate},
	volume = {136},
	number = {2},
	journal = {Artificial Intelligence},
	author = {Bowling, Michael and Veloso, Manuela},
	year = {2002},
	note = {Publisher: Elsevier},
	pages = {215--250},
}

@inproceedings{leijen_mimalloc_2019,
	title = {Mimalloc: {Free} list sharding in action},
	booktitle = {Programming {Languages} and {Systems}: 17th {Asian} {Symposium}, {APLAS} 2019, {Nusa} {Dua}, {Bali}, {Indonesia}, {December} 1–4, 2019, {Proceedings} 17},
	publisher = {Springer International Publishing},
	author = {Leijen, Daan and Zorn, Benjamin and de Moura, Leonardo},
	year = {2019},
	keywords = {to-read},
	pages = {244--265},
	file = {Leijen et al. - 2019 - Mimalloc Free list sharding in action.pdf:/Users/timwhiting/Zotero/storage/VUBN293D/Leijen et al. - 2019 - Mimalloc Free list sharding in action.pdf:application/pdf},
}

@article{wang_learning_2020,
	title = {Learning context-aware task reasoning for efficient meta-reinforcement learning},
	journal = {arXiv preprint arXiv:2003.01373},
	author = {Wang, Haozhe and Zhou, Jiale and He, Xuming},
	year = {2020},
}

@article{mercuur_integrating_2020,
	title = {Integrating social practice theory in agent-based models: {A} review of theories and agents},
	volume = {7},
	number = {5},
	journal = {IEEE Transactions on Computational Social Systems},
	author = {Mercuur, Rijk and Dignum, Virginia and Jonker, Catholijn M},
	year = {2020},
	note = {Publisher: IEEE},
	pages = {1131--1145},
}

@inproceedings{littman_leading_2001,
	title = {Leading best-response strategies in repeated games},
	booktitle = {Seventeenth {Annual} {International} {Joint} {Conference} on {Artificial} {Intelligence} {Workshop} on {Economic} {Agents}, {Models}, and {Mechanisms}},
	author = {Littman, Michael L and Stone, Peter},
	year = {2001},
}

@inproceedings{stimpson_learning_2003,
	title = {Learning to cooperate in a social dilemma: {A} satisficing approach to bargaining},
	booktitle = {Proceedings of the 20th international conference on machine learning ({ICML}-03)},
	author = {Stimpson, Jeff L and Goodrich, Michael A},
	year = {2003},
	pages = {728--735},
}

@article{mellema_linking_2022,
	title = {Linking sanctions to norms in practice},
	journal = {arXiv preprint arXiv:2205.10295},
	author = {Mellema, René and Dignum, Frank},
	year = {2022},
}

@article{foerster_learning_2017,
	title = {Learning with opponent-learning awareness},
	journal = {arXiv preprint arXiv:1709.04326},
	author = {Foerster, Jakob N and Chen, Richard Y and Al-Shedivat, Maruan and Whiteson, Shimon and Abbeel, Pieter and Mordatch, Igor},
	year = {2017},
}

@inproceedings{bensch_increasing_2022,
	title = {Increasing robot understandability through social practices},
	booktitle = {Ro-{Man} 2022, 31st {IEEE} {International} {Conference} on {Robot} and {Human} {Interactive} {Communication}, {Naples}, {Italy}, {Aug} 29-{September} 2, 2022},
	author = {Bensch, Suna and Dignum, Frank and Hellström, Thomas},
	year = {2022},
}

@article{de_farias_how_2003,
	title = {How to combine expert (and novice) advice when actions impact the environment?},
	volume = {16},
	journal = {Advances in neural information processing systems},
	author = {de Farias, Daniela and Megiddo, Nimrod},
	year = {2003},
}

@inproceedings{yahiro_game_2020,
	title = {Game theoretic analysis for two-sided matching with resource allocation},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Autonomous} {Agents} and {MultiAgent} {Systems}},
	author = {Yahiro, Kentaro and Yokoo, Makoto},
	year = {2020},
	pages = {1548--1556},
}

@inproceedings{littman_friend-or-foe_2001,
	title = {Friend-or-foe {Q}-learning in general-sum games},
	volume = {1},
	booktitle = {{ICML}},
	author = {Littman, Michael L},
	year = {2001},
	pages = {322--328},
}

@inproceedings{dignum_autistic_2014,
	title = {From autistic to social agents},
	booktitle = {Proceedings of the 2014 international conference on {Autonomous} {Agents} and {Multi}-{Agent} {Systems}},
	author = {Dignum, Frank and Prada, Rui and Hofstede, Gert Jan},
	year = {2014},
	pages = {1161--1164},
}

@article{dennis_formal_2016,
	title = {Formal verification of ethical choices in autonomous systems},
	volume = {77},
	journal = {Robotics and Autonomous Systems},
	author = {Dennis, Louise and Fisher, Michael and Slavkovik, Marija and Webster, Matt},
	year = {2016},
	note = {Publisher: Elsevier},
	pages = {1--14},
}

@inproceedings{fan_extending_2005,
	title = {Extending the recognition-primed decision model to support human-agent collaboration},
	booktitle = {Proceedings of the fourth international joint conference on {Autonomous} agents and multiagent systems},
	author = {Fan, Xiaocong and Sun, Shuang and McNeese, Michale and Yen, John},
	year = {2005},
	pages = {945--952},
}

@article{karandikar_evolving_1998,
	title = {Evolving aspirations and cooperation},
	volume = {80},
	number = {2},
	journal = {journal of economic theory},
	author = {Karandikar, Rajeeva and Mookherjee, Dilip and Ray, Debraj and Vega-Redondo, Fernando},
	year = {1998},
	note = {Publisher: Elsevier},
	pages = {292--331},
}

@article{barcelo_dynamic_2005,
	title = {Dynamic network simulation with {AIMSUN}},
	journal = {Simulation approaches in transportation analysis: Recent advances and challenges},
	author = {Barceló, Jaime and Casas, Jordi},
	year = {2005},
	note = {Publisher: Springer US},
	pages = {57--98},
}

@inproceedings{castelfranchi_deliberative_2000,
	title = {Deliberative normative agents: {Principles} and architecture},
	booktitle = {Intelligent {Agents} {VI}. {Agent} {Theories}, {Architectures}, and {Languages}: 6th {International} {Workshop}, {ATAL}’99, {Orlando}, {Florida}, {USA}, {July} 15-17, 1999. {Proceedings} 6},
	publisher = {Springer Berlin Heidelberg},
	author = {Castelfranchi, Cristiano and Dignum, Frank and Jonker, Catholijn M and Treur, Jan},
	year = {2000},
	pages = {364--378},
}

@inproceedings{kaminka_curing_2013,
	title = {Curing robot autism: {A} challenge},
	booktitle = {Proceedings of the 2013 international conference on {Autonomous} agents and multi-agent systems},
	publisher = {Citeseer},
	author = {Kaminka, Gal A},
	year = {2013},
	pages = {801--804},
}

@article{crandall_cooperating_2018,
	title = {Cooperating with machines},
	volume = {9},
	number = {1},
	journal = {Nature communications},
	author = {Crandall, Jacob W and Oudah, Mayada and Ishowo-Oloko, Fatimah and Abdallah, Sherief and Bonnefon, Jean-François and Cebrian, Manuel and Shariff, Azim and Goodrich, Michael A and Rahwan, Iyad},
	year = {2018},
	note = {Publisher: Nature Publishing Group UK London},
	pages = {233},
	file = {Crandall et al_2018_Cooperating with machines.pdf:/Users/timwhiting/Zotero/storage/XGEZPUFU/Crandall et al_2018_Cooperating with machines.pdf:application/pdf;Crandall et al_2018_Cooperating with machines2.pdf:/Users/timwhiting/Zotero/storage/L4L9BAZU/Crandall et al_2018_Cooperating with machines2.pdf:application/pdf},
}

@article{bowling_convergence_2004,
	title = {Convergence and no-regret in multiagent learning},
	volume = {17},
	journal = {Advances in neural information processing systems},
	author = {Bowling, Michael},
	year = {2004},
}

@article{whiting_confronting_2021,
	title = {Confronting barriers to human-robot cooperation: balancing efficiency and risk in machine behavior},
	volume = {24},
	number = {1},
	journal = {Iscience},
	author = {Whiting, Tim and Gautam, Alvika and Tye, Jacob and Simmons, Michael and Henstrom, Jordan and Oudah, Mayada and Crandall, Jacob W},
	year = {2021},
	note = {Publisher: Elsevier},
	pages = {101963},
	file = {Whiting et al_2021_Confronting barriers to human-robot cooperation.pdf:/Users/timwhiting/Zotero/storage/PNZ55GJ9/Whiting et al_2021_Confronting barriers to human-robot cooperation.pdf:application/pdf;Whiting et al_2021_Confronting barriers to human-robot cooperation2.pdf:/Users/timwhiting/Zotero/storage/S8TJNRB3/Whiting et al_2021_Confronting barriers to human-robot cooperation2.pdf:application/pdf;Whiting et al_2021_Confronting barriers to human-robot cooperation3.pdf:/Users/timwhiting/Zotero/storage/YEXGTS88/Whiting et al_2021_Confronting barriers to human-robot cooperation3.pdf:application/pdf},
}

@book{chai_choosing_2001,
	title = {Choosing an identity: {A} general model of preference and belief formation},
	publisher = {University of Michigan Press},
	author = {Chai, Sun-Ki},
	year = {2001},
}

@inproceedings{kammler_changing_2022,
	title = {Changing perspectives: adaptable interpretations of norms for agents},
	booktitle = {Multi-{Agent}-{Based} {Simulation} {XXII}: 22nd {International} {Workshop}, {MABS} 2021, {Virtual} {Event}, {May} 3-7, 2021, {Revised} {Selected} {Papers}},
	publisher = {Springer International Publishing Cham},
	author = {Kammler, Christian and Dignum, Frank and Wijermans, Nanda and Lindgren, Helena},
	year = {2022},
	pages = {139--152},
}

@article{dignum_autonomous_1999,
	title = {Autonomous agents with norms},
	volume = {7},
	journal = {Artificial intelligence and law},
	author = {Dignum, Frank},
	year = {1999},
	note = {Publisher: Kluwer Academic Publishers},
	pages = {69--79},
}

@inproceedings{dignum_agents_2020,
	title = {Agents are dead. {Long} live agents!},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Autonomous} {Agents} and {MultiAgent} {Systems}},
	author = {Dignum, Virginia and Dignum, Frank},
	year = {2020},
	pages = {1701--1705},
}

@incollection{erdogan_abstracting_2022,
	title = {Abstracting {Minds}: {Computational} {Theory} of {Mind} for {Human}-{Agent} {Collaboration}},
	booktitle = {{HHAI2022}: {Augmenting} {Human} {Intellect}},
	publisher = {IOS Press},
	author = {Erdogan, Emre and Dignum, Frank and Verbrugge, Rineke and Yolum, Pınar},
	year = {2022},
	pages = {199--211},
}

@inproceedings{van_horn_abstracting_2010,
	title = {Abstracting abstract machines},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} international conference on {Functional} programming},
	author = {Van Horn, David and Might, Matthew},
	year = {2010},
	keywords = {to-read},
	pages = {51--62},
	file = {Van Horn_Might_2010_Abstracting abstract machines.pdf:/Users/timwhiting/Zotero/storage/ZYMFDZC2/Van Horn_Might_2010_Abstracting abstract machines.pdf:application/pdf;Van Horn_Might_2010_Abstracting abstract machines2.pdf:/Users/timwhiting/Zotero/storage/9DCMRDTT/Van Horn_Might_2010_Abstracting abstract machines2.pdf:application/pdf},
}

@article{de_cote_polynomial-time_2012,
	title = {A polynomial-time {Nash} equilibrium algorithm for repeated stochastic games},
	journal = {arXiv preprint arXiv:1206.3277},
	author = {De Cote, Enrique Munoz and Littman, Michael L},
	year = {2012},
}

@inproceedings{gautam_method_2022,
	title = {A {Method} for {Designing} {Autonomous} {Robots} that {Know} {Their} {Limits}},
	booktitle = {2022 {International} {Conference} on {Robotics} and {Automation} ({ICRA})},
	publisher = {IEEE},
	author = {Gautam, Alvika and Whiting, Tim and Cao, Xuan and Goodrich, Michael A and Crandall, Jacob W},
	year = {2022},
	pages = {121--127},
}

@article{dignum_conceptual_2015,
	title = {A conceptual architecture for social deliberation in multi-agent organizations},
	volume = {11},
	number = {3},
	journal = {Multiagent and Grid Systems},
	author = {Dignum, Frank and Dignum, Virginia and Prada, Rui and Jonker, Catholijn M},
	year = {2015},
	note = {Publisher: IOS Press},
	pages = {147--166},
}

@inproceedings{wadler_how_1989,
	title = {How to make ad-hoc polymorphism less ad hoc},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Wadler, Philip and Blott, Stephen},
	year = {1989},
	keywords = {to-read},
	pages = {60--76},
	file = {Wadler and Blott - 1989 - How to make ad-hoc polymorphism less ad hoc.pdf:/Users/timwhiting/Zotero/storage/AI922P9M/Wadler and Blott - 1989 - How to make ad-hoc polymorphism less ad hoc.pdf:application/pdf},
}

@inproceedings{omar_filling_2021,
	title = {Filling typed holes with live {GUIs}},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	author = {Omar, Cyrus and Moon, David and Blinn, Andrew and Voysey, Ian and Collins, Nick and Chugh, Ravi},
	year = {2021},
	keywords = {to-read},
	pages = {511--525},
}

@inproceedings{downen_codata_2019,
	title = {Codata in action},
	booktitle = {Programming {Languages} and {Systems}: 28th {European} {Symposium} on {Programming}, {ESOP} 2019, {Held} as {Part} of the {European} {Joint} {Conferences} on {Theory} and {Practice} of {Software}, {ETAPS} 2019, {Prague}, {Czech} {Republic}, {April} 6–11, 2019, {Proceedings}},
	publisher = {Springer International Publishing Cham},
	author = {Downen, Paul and Sullivan, Zachary and Ariola, Zena M and Peyton Jones, Simon},
	year = {2019},
	keywords = {to-read},
	pages = {119--146},
}

@article{morris_abstracting_2019,
	title = {Abstracting extensible data types: or, rows by any other name},
	volume = {3},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Morris, J Garrett and McKinna, James},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--28},
	file = {Morris and McKinna - 2019 - Abstracting extensible data types or, rows by any.pdf:/Users/timwhiting/Zotero/storage/S6SF9YVF/Morris and McKinna - 2019 - Abstracting extensible data types or, rows by any.pdf:application/pdf},
}

@article{plotkin_tensors_2008,
	title = {Tensors of comodels and models for operational semantics},
	volume = {218},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Plotkin, Gordon and Power, John},
	year = {2008},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {295--311},
	file = {Plotkin and Power - 2008 - Tensors of comodels and models for operational sem.pdf:/Users/timwhiting/Zotero/storage/4FB6H75P/Plotkin and Power - 2008 - Tensors of comodels and models for operational sem.pdf:application/pdf},
}

@article{christiansen_bidirectional_2013,
	title = {Bidirectional typing rules: {A} tutorial},
	author = {Christiansen, David Raymond},
	year = {2013},
	keywords = {to-read},
	file = {Christiansen - 2013 - Bidirectional typing rules A tutorial.pdf:/Users/timwhiting/Zotero/storage/YCU37TXY/Christiansen - 2013 - Bidirectional typing rules A tutorial.pdf:application/pdf},
}

@inproceedings{kuper_lvars_2013,
	title = {{LVars}: lattice-based data structures for deterministic parallelism},
	booktitle = {Proceedings of the 2nd {ACM} {SIGPLAN} workshop on {Functional} high-performance computing},
	author = {Kuper, Lindsey and Newton, Ryan R},
	year = {2013},
	keywords = {to-read},
	pages = {71--84},
}

@article{hinze_chapter_2003,
	title = {Chapter 2. {Generic} {Haskell}: {Applications}},
	journal = {Generic Programming: Advanced Lectures},
	author = {Hinze, Ralf and Jeuring, Johan},
	year = {2003},
	note = {Publisher: Springer Berlin Heidelberg},
	keywords = {to-read},
	pages = {57--96},
}

@inproceedings{martins_zipper-based_2013,
	title = {Zipper-based attribute grammars and their extensions},
	booktitle = {Programming {Languages}: 17th {Brazilian} {Symposium}, {SBLP} 2013, {Brasília}, {Brazil}, {October} 3-4, 2013. {Proceedings} 17},
	publisher = {Springer Berlin Heidelberg},
	author = {Martins, Pedro and Fernandes, João Paulo and Saraiva, João},
	year = {2013},
	keywords = {to-read},
	pages = {135--149},
}

@article{allwood_strengthening_2010,
	title = {Strengthening the zipper},
	volume = {253},
	number = {7},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Allwood, Tristan OR and Eisenbach, Susan},
	year = {2010},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {3--18},
}

@inproceedings{hudak_aggregate_1985,
	title = {The aggregate update problem in functional programming systems},
	booktitle = {Proceedings of the 12th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages},
	author = {Hudak, Paul and Bloss, Adrienne},
	year = {1985},
	keywords = {to-read},
	pages = {300--314},
}

@article{ehrhard_differential_2003,
	title = {The differential lambda-calculus},
	volume = {309},
	number = {1-3},
	journal = {Theoretical Computer Science},
	author = {Ehrhard, Thomas and Regnier, Laurent},
	year = {2003},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {1--41},
}

@article{altenkirch_indexed_2015,
	title = {Indexed containers},
	volume = {25},
	journal = {Journal of Functional Programming},
	author = {Altenkirch, Thorsten and Ghani, Neil and Hancock, Peter and McBride, Conor and Morris, Peter},
	year = {2015},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {e5},
}

@article{amin_collapsing_2017,
	title = {Collapsing towers of interpreters},
	volume = {2},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Amin, Nada and Rompf, Tiark},
	year = {2017},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--33},
	file = {Amin and Rompf - 2017 - Collapsing towers of interpreters.pdf:/Users/timwhiting/Zotero/storage/ETV2YI7V/Amin and Rompf - 2017 - Collapsing towers of interpreters.pdf:application/pdf},
}

@inproceedings{felleisen_expressive_2005,
	title = {On the expressive power of programming languages},
	booktitle = {{ESOP}'90: 3rd {European} {Symposium} on {Programming} {Copenhagen}, {Denmark}, {May} 15–18, 1990 {Proceedings}},
	publisher = {Springer Berlin Heidelberg Berlin, Heidelberg},
	author = {Felleisen, Matthias},
	year = {2005},
	keywords = {to-read},
	pages = {134--151},
	file = {Felleisen - 2005 - On the expressive power of programming languages.pdf:/Users/timwhiting/Zotero/storage/NSV6GLEA/Felleisen - 2005 - On the expressive power of programming languages.pdf:application/pdf},
}

@article{yallop_staged_2017,
	title = {Staged generic programming.},
	volume = {1},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Yallop, Jeremy},
	year = {2017},
	keywords = {to-read},
	pages = {29--1},
	file = {Yallop - 2017 - Staged generic programming..pdf:/Users/timwhiting/Zotero/storage/2MLUMIKW/Yallop - 2017 - Staged generic programming..pdf:application/pdf},
}

@article{flatt_binding_2016,
	title = {Binding as sets of scopes},
	volume = {51},
	number = {1},
	journal = {ACM SIGPLAN Notices},
	author = {Flatt, Matthew},
	year = {2016},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {705--717},
	file = {Flatt - 2016 - Binding as sets of scopes.pdf:/Users/timwhiting/Zotero/storage/5I2E6ZNN/Flatt - 2016 - Binding as sets of scopes.pdf:application/pdf},
}

@inproceedings{culpepper_macros_2019,
	title = {From macros to dsls: {The} evolution of racket},
	booktitle = {3rd summit on advances in programming languages (snapl 2019)},
	publisher = {Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik},
	author = {Culpepper, Ryan and Felleisen, Matthias and Flatt, Matthew and Krishnamurthi, Shriram},
	year = {2019},
	keywords = {to-read},
	file = {Culpepper et al. - 2019 - From macros to dsls The evolution of racket.pdf:/Users/timwhiting/Zotero/storage/CU9IKH9N/Culpepper et al. - 2019 - From macros to dsls The evolution of racket.pdf:application/pdf},
}

@article{flatt_composable_2002,
	title = {Composable and compilable macros: you want it when?},
	volume = {37},
	number = {9},
	journal = {ACM SIGPLAN Notices},
	author = {Flatt, Matthew},
	year = {2002},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {72--83},
	file = {Flatt - 2002 - Composable and compilable macros you want it when.pdf:/Users/timwhiting/Zotero/storage/ZXSRF34N/Flatt - 2002 - Composable and compilable macros you want it when.pdf:application/pdf},
}

@article{van_antwerpen_scopes_2018,
	title = {Scopes as types},
	volume = {2},
	number = {OOPSLA},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {van Antwerpen, Hendrik and Bach Poulsen, Casper and Rouvoet, Arjen and Visser, Eelco},
	year = {2018},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--30},
	file = {van Antwerpen et al. - 2018 - Scopes as types.pdf:/Users/timwhiting/Zotero/storage/H9CINDJX/van Antwerpen et al. - 2018 - Scopes as types.pdf:application/pdf},
}

@article{felleisen_programmable_2018,
	title = {A programmable programming language},
	volume = {61},
	number = {3},
	journal = {Communications of the ACM},
	author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram and Barzilay, Eli and McCarthy, Jay and Tobin-Hochstadt, Sam},
	year = {2018},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {62--71},
	file = {Felleisen et al. - 2018 - A programmable programming language.pdf:/Users/timwhiting/Zotero/storage/APTUTK4X/Felleisen et al. - 2018 - A programmable programming language.pdf:application/pdf},
}

@article{bindings_macros_2002,
	title = {Macros that {Work} {Together}},
	author = {Bindings, Compile-Time and Flatt, Matthew and Culpepper, Ryan and Darais, David and Findler, Robert Bruce},
	year = {2002},
	keywords = {to-read},
	file = {Bindings et al. - 2002 - Macros that Work Together.pdf:/Users/timwhiting/Zotero/storage/2BEAIB5F/Bindings et al. - 2002 - Macros that Work Together.pdf:application/pdf},
}

@article{flatt_submodules_2013,
	title = {Submodules in racket: you want it when, again?},
	volume = {49},
	number = {3},
	journal = {ACM SIGPLAN Notices},
	author = {Flatt, Matthew},
	year = {2013},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {13--22},
	file = {Flatt - 2013 - Submodules in racket you want it when, again.pdf:/Users/timwhiting/Zotero/storage/B7XVK5U7/Flatt - 2013 - Submodules in racket you want it when, again.pdf:application/pdf},
}

@article{de_moura_beyond_2022,
	title = {Beyond {Notations}: {Hygienic} {Macro} {Expansion} for {Theorem} {Proving} {Languages}},
	volume = {18},
	journal = {Logical Methods in Computer Science},
	author = {de Moura, Leonardo and Ullrich, Sebastian},
	year = {2022},
	note = {Publisher: Episciences. org},
	keywords = {to-read},
	file = {de Moura and Ullrich - 2022 - Beyond Notations Hygienic Macro Expansion for The.pdf:/Users/timwhiting/Zotero/storage/HYEP5FXU/de Moura and Ullrich - 2022 - Beyond Notations Hygienic Macro Expansion for The.pdf:application/pdf},
}

@inproceedings{handlers_fusion_2015,
	title = {Fusion for {Free}},
	volume = {9129},
	booktitle = {Mathematics of {Program} {Construction}: 12th {International} {Conference}, {MPC} 2015, {Königswinter}, {Germany}, {June} 29–{July} 1, 2015. {Proceedings}},
	publisher = {Springer},
	author = {Handlers, Efficient Algebraic Effect},
	year = {2015},
	keywords = {to-read},
	pages = {302},
}

@article{yang_reasoning_2021,
	title = {Reasoning about effect interaction by fusion},
	volume = {5},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Yang, Zhixuan and Wu, Nicolas},
	year = {2021},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--29},
}

@article{ghica_high-level_2022,
	title = {High-{Level} {Effect} {Handlers} in {C}+},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Ghica, Dan and Lindley, Sam and Bravo, Marcos Maroñas and Piróg, Maciej},
	year = {2022},
	note = {Publisher: Association for Computing Machinery (ACM)},
	keywords = {to-read},
	file = {Ghica et al. - 2022 - High-Level Effect Handlers in C+.pdf:/Users/timwhiting/Zotero/storage/B8ZNVN4A/Ghica et al. - 2022 - High-Level Effect Handlers in C+.pdf:application/pdf},
}

@inproceedings{pirog_syntax_2018,
	title = {Syntax and semantics for operations with scopes},
	booktitle = {Proceedings of the 33rd {Annual} {ACM}/{IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	author = {Piróg, Maciej and Schrijvers, Tom and Wu, Nicolas and Jaskelioff, Mauro},
	year = {2018},
	keywords = {to-read},
	pages = {809--818},
}

@article{bach_poulsen_hefty_2023,
	title = {Hefty {Algebras}: {Modular} {Elaboration} of {Higher}-{Order} {Algebraic} {Effects}},
	volume = {7},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Bach Poulsen, Casper and van der Rest, Cas},
	year = {2023},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1801--1831},
	file = {Bach Poulsen and van der Rest - 2023 - Hefty Algebras Modular Elaboration of Higher-Orde.pdf:/Users/timwhiting/Zotero/storage/XJ4BLYW9/Bach Poulsen and van der Rest - 2023 - Hefty Algebras Modular Elaboration of Higher-Orde.pdf:application/pdf},
}

@inproceedings{pinckney_wasmk_2020,
	title = {Wasm/k: delimited continuations for {WebAssembly}},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} {International} {Symposium} on {Dynamic} {Languages}},
	author = {Pinckney, Donald and Guha, Arjun and Brun, Yuriy},
	year = {2020},
	pages = {16--28},
}

@article{bauer_programming_2015,
	title = {Programming with algebraic effects and handlers},
	volume = {84},
	number = {1},
	journal = {Journal of logical and algebraic methods in programming},
	author = {Bauer, Andrej and Pretnar, Matija},
	year = {2015},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {108--123},
	file = {Bauer and Pretnar - 2015 - Programming with algebraic effects and handlers.pdf:/Users/timwhiting/Zotero/storage/4H34Y86C/Bauer and Pretnar - 2015 - Programming with algebraic effects and handlers.pdf:application/pdf},
}

@phdthesis{niimi_extending_2021,
	type = {{PhD} {Thesis}},
	title = {Extending {Effekt} with {Bidirectional} {Effects}},
	school = {Tokyo Institute OF Technology},
	author = {NIIMI, Kazuki},
	year = {2021},
	keywords = {to-read},
}

@article{convent_adaptive_nodate,
	title = {Adaptive {Effect} {Handling} in {Frank}},
	author = {Convent, Lukas},
	keywords = {to-read},
}

@article{kammar_no_2017,
	title = {No value restriction is needed for algebraic effects and handlers},
	volume = {27},
	journal = {Journal of functional programming},
	author = {Kammar, Ohad and Pretnar, Matija},
	year = {2017},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {e7},
}

@article{pretnar_introduction_2015,
	title = {An introduction to algebraic effects and handlers. invited tutorial paper},
	volume = {319},
	journal = {Electronic notes in theoretical computer science},
	author = {Pretnar, Matija},
	year = {2015},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {19--35},
}

@article{brachthauser_effects_2020,
	title = {Effects as capabilities: effect handlers and lightweight effect polymorphism},
	volume = {4},
	number = {OOPSLA},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Brachthäuser, Jonathan Immanuel and Schuster, Philipp and Ostermann, Klaus},
	year = {2020},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--30},
	file = {Brachthäuser et al. - 2020 - Effects as capabilities effect handlers and light.pdf:/Users/timwhiting/Zotero/storage/ZMKLGBE6/Brachthäuser et al. - 2020 - Effects as capabilities effect handlers and light.pdf:application/pdf},
}

@inproceedings{hillerstrom_shallow_2018,
	title = {Shallow effect handlers},
	booktitle = {Programming {Languages} and {Systems}: 16th {Asian} {Symposium}, {APLAS} 2018, {Wellington}, {New} {Zealand}, {December} 2–6, 2018, {Proceedings} 16},
	publisher = {Springer International Publishing},
	author = {Hillerström, Daniel and Lindley, Sam},
	year = {2018},
	keywords = {to-read},
	pages = {415--435},
	file = {Hillerström and Lindley - 2018 - Shallow effect handlers.pdf:/Users/timwhiting/Zotero/storage/ZBYJ3TY9/Hillerström and Lindley - 2018 - Shallow effect handlers.pdf:application/pdf},
}

@article{biernacki_handle_2017,
	title = {Handle with care: relational interpretation of algebraic effects and handlers},
	volume = {2},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Biernacki, Dariusz and Piróg, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	year = {2017},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--30},
	file = {Biernacki et al. - 2017 - Handle with care relational interpretation of alg.pdf:/Users/timwhiting/Zotero/storage/Q7K2N8PM/Biernacki et al. - 2017 - Handle with care relational interpretation of alg.pdf:application/pdf},
}

@article{bracevac_versatile_2018,
	title = {Versatile event correlation with algebraic effects},
	volume = {2},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Bračevac, Oliver and Amin, Nada and Salvaneschi, Guido and Erdweg, Sebastian and Eugster, Patrick and Mezini, Mira},
	year = {2018},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--31},
}

@article{de_vilhena_type_2022,
	title = {A {Type} {System} for {Effect} {Handlers} and {Dynamic} {Labels}},
	author = {de Vilhena, Paulo Emílio and Pottier, François},
	year = {2022},
	keywords = {to-read},
}

@article{zhang_handling_2020,
	title = {Handling bidirectional control flow},
	volume = {4},
	number = {OOPSLA},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Zhang, Yizhou and Salvaneschi, Guido and Myers, Andrew C},
	year = {2020},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--30},
	file = {Zhang et al. - 2020 - Handling bidirectional control flow.pdf:/Users/timwhiting/Zotero/storage/JXACGVJ6/Zhang et al. - 2020 - Handling bidirectional control flow.pdf:application/pdf},
}

@article{biernacki_binders_2020,
	title = {Binders by {Day}, {Labels} by {Night}},
	author = {BIERNACKI, DARIUSZ and PIRÓG, MACIEJ and POLESIUK, PIOTR and SIECZKOWSKI, FILIP},
	year = {2020},
	keywords = {to-read},
}

@article{biernacki_binders_2019,
	title = {Binders by day, labels by night: effect instances via lexically scoped handlers},
	volume = {4},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Biernacki, Dariusz and Piróg, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--29},
	file = {Biernacki et al. - 2019 - Binders by day, labels by night effect instances .pdf:/Users/timwhiting/Zotero/storage/P369EY33/Biernacki et al. - 2019 - Binders by day, labels by night effect instances .pdf:application/pdf},
}

@phdthesis{geron_defined_2020,
	type = {{PhD} {Thesis}},
	title = {Defined algebraic operations},
	school = {University of Birmingham},
	author = {Geron, Bram},
	year = {2020},
	keywords = {to-read},
}

@article{kung_survey_2018,
	title = {A {Survey} of {Algebraic} {Effect} {System}},
	author = {Kung, Ryan J},
	year = {2018},
	keywords = {to-read},
}

@article{zhang_abstraction-safe_2019,
	title = {Abstraction-safe effect handlers via tunneling},
	volume = {3},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Zhang, Yizhou and Myers, Andrew C},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--29},
	file = {Zhang and Myers - 2019 - Abstraction-safe effect handlers via tunneling.pdf:/Users/timwhiting/Zotero/storage/W8H2BV7H/Zhang and Myers - 2019 - Abstraction-safe effect handlers via tunneling.pdf:application/pdf},
}

@article{convent_doo_2020,
	title = {Doo bee doo bee doo},
	volume = {30},
	journal = {Journal of Functional Programming},
	author = {Convent, Lukas and Lindley, Sam and McBride, Conor and McLaughlin, Craig},
	year = {2020},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {e9},
	file = {Convent et al. - 2020 - Doo bee doo bee doo.pdf:/Users/timwhiting/Zotero/storage/KXPKZN22/Convent et al. - 2020 - Doo bee doo bee doo.pdf:application/pdf},
}

@article{ahman_asynchronous_2021,
	title = {Asynchronous effects},
	volume = {5},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Ahman, Danel and Pretnar, Matija},
	year = {2021},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--28},
	file = {Ahman_Pretnar_2021_Asynchronous effects.pdf:/Users/timwhiting/Zotero/storage/CDQZ9RX6/Ahman_Pretnar_2021_Asynchronous effects.pdf:application/pdf},
}

@inproceedings{wu_fusion_2015,
	title = {Fusion for free: {Efficient} algebraic effect handlers},
	booktitle = {Mathematics of {Program} {Construction}: 12th {International} {Conference}, {MPC} 2015, {Königswinter}, {Germany}, {June} 29–{July} 1, 2015. {Proceedings} 12},
	publisher = {Springer International Publishing},
	author = {Wu, Nicolas and Schrijvers, Tom},
	year = {2015},
	pages = {302--322},
	file = {Wu and Schrijvers - 2015 - Fusion for free Efficient algebraic effect handle.pdf:/Users/timwhiting/Zotero/storage/VB552ZZ5/Wu and Schrijvers - 2015 - Fusion for free Efficient algebraic effect handle.pdf:application/pdf},
}

@article{sigal_automatic_2021,
	title = {Automatic differentiation via effects and handlers: {An} implementation in {Frank}},
	journal = {arXiv preprint arXiv:2101.08095},
	author = {Sigal, Jesse},
	year = {2021},
	keywords = {to-read},
}

@inproceedings{chandrasekaran_algebraic_2018,
	title = {Algebraic effect handlers go mainstream (dagstuhl seminar 18172)},
	volume = {8},
	booktitle = {Dagstuhl reports},
	publisher = {Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik},
	author = {Chandrasekaran, Sivaramakrishnan Krishnamoorthy and Leijen, Daan and Pretnar, Matija and Schrijvers, Tom},
	year = {2018},
	note = {Issue: 4},
	keywords = {to-read},
}

@article{xie_parallel_2021,
	title = {Parallel {Algebraic} {Effect} {Handlers}},
	journal = {arXiv preprint arXiv:2110.07493},
	author = {Xie, Ningning and Johnson, Daniel D and Maclaurin, Dougal and Paszke, Adam},
	year = {2021},
	keywords = {to-read},
}

@article{lindley_be_nodate,
	title = {Do {Be} {Do}. {In}: {POPL}'2017. {ACM}, {New} {York}, pp. 500-514. {ISBN} 9781450346603, http://dx. doi. org/10.1145/3009837.3009897},
	author = {Lindley, Sam and McBride, Conor and McLaughlin, Craig},
	keywords = {to-read},
}

@inproceedings{xie_effect_2020,
	title = {Effect handlers in {Haskell}, evidently},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} {International} {Symposium} on {Haskell}},
	author = {Xie, Ningning and Leijen, Daan},
	year = {2020},
	keywords = {to-read},
	pages = {95--108},
	file = {Xie and Leijen - 2020 - Effect handlers in Haskell, evidently.pdf:/Users/timwhiting/Zotero/storage/7APFIGLE/Xie and Leijen - 2020 - Effect handlers in Haskell, evidently.pdf:application/pdf},
}

@article{kiselyov_implementing_2014,
	title = {Implementing, and {Understanding} {Type} {Classes}},
	journal = {updated November},
	author = {Kiselyov, Oleg},
	year = {2014},
	keywords = {to-read},
}

@inproceedings{jones_type_1997,
	title = {Type classes: an exploration of the design space},
	booktitle = {Haskell workshop},
	author = {Jones, Simon Peyton and Jones, Mark and Meijer, Erik},
	year = {1997},
	keywords = {to-read},
	pages = {1--16},
	file = {Jones et al. - 1997 - Type classes an exploration of the design space.pdf:/Users/timwhiting/Zotero/storage/LHF82IUC/Jones et al. - 1997 - Type classes an exploration of the design space.pdf:application/pdf},
}

@inproceedings{dreyer_modular_2007,
	title = {Modular type classes},
	booktitle = {Proceedings of the 34th annual {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Dreyer, Derek and Harper, Robert and Chakravarty, Manuel MT and Keller, Gabriele},
	year = {2007},
	keywords = {to-read},
	pages = {63--70},
	file = {Dreyer et al. - 2007 - Modular type classes.pdf:/Users/timwhiting/Zotero/storage/LHQH9U9K/Dreyer et al. - 2007 - Modular type classes.pdf:application/pdf},
}

@article{white_modular_2015,
	title = {Modular implicits},
	journal = {arXiv preprint arXiv:1512.01895},
	author = {White, Leo and Bour, Frédéric and Yallop, Jeremy},
	year = {2015},
	keywords = {to-read},
	file = {White et al. - 2015 - Modular implicits.pdf:/Users/timwhiting/Zotero/storage/Y7PLEQJ7/White et al. - 2015 - Modular implicits.pdf:application/pdf},
}

@inproceedings{sozeau_first-class_2008,
	title = {First-class type classes},
	booktitle = {Theorem {Proving} in {Higher} {Order} {Logics}: 21st {International} {Conference}, {TPHOLs} 2008, {Montreal}, {Canada}, {August} 18-21, 2008. {Proceedings} 21},
	publisher = {Springer Berlin Heidelberg},
	author = {Sozeau, Matthieu and Oury, Nicolas},
	year = {2008},
	keywords = {to-read},
	pages = {278--293},
	file = {Sozeau and Oury - 2008 - First-class type classes.pdf:/Users/timwhiting/Zotero/storage/5AVL255B/Sozeau and Oury - 2008 - First-class type classes.pdf:application/pdf},
}

@inproceedings{jones_type_2000,
	title = {Type classes with functional dependencies},
	booktitle = {Programming {Languages} and {Systems}: 9th {European} {Symposium} on {Programming}, {ESOP} 2000 {Held} as {Part} of the {Joint} {European} {Conferences} on {Theory} and {Practice} of {Software}, {ETAPS} 2000 {Berlin}, {Germany}, {March} 25–{April} 2, 2000 {Proceedings}},
	publisher = {Springer Berlin Heidelberg Berlin, Heidelberg},
	author = {Jones, Mark P},
	year = {2000},
	keywords = {to-read},
	pages = {230--244},
	file = {Jones - 2000 - Type classes with functional dependencies.pdf:/Users/timwhiting/Zotero/storage/E324EWLG/Jones - 2000 - Type classes with functional dependencies.pdf:application/pdf},
}

@article{peterson_implementing_1993,
	title = {Implementing type classes},
	volume = {28},
	number = {6},
	journal = {ACM SIGPLAN Notices},
	author = {Peterson, John and Jones, Mark},
	year = {1993},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {227--236},
	file = {Peterson and Jones - 1993 - Implementing type classes.pdf:/Users/timwhiting/Zotero/storage/UMIHJLGR/Peterson and Jones - 1993 - Implementing type classes.pdf:application/pdf},
}

@article{thompson_reflections_1984,
	title = {Reflections on trusting trust},
	volume = {27},
	number = {8},
	journal = {Communications of the ACM},
	author = {Thompson, Ken},
	year = {1984},
	note = {Publisher: ACM New York, NY, USA},
	pages = {761--763},
}

@article{castagna_programming_2021,
	title = {Programming with union, intersection, and negation types},
	journal = {arXiv preprint arXiv:2111.03354},
	author = {Castagna, Giuseppe},
	year = {2021},
	keywords = {to-read},
	file = {Castagna - 2021 - Programming with union, intersection, and negation.pdf:/Users/timwhiting/Zotero/storage/HJHL5CE3/Castagna - 2021 - Programming with union, intersection, and negation.pdf:application/pdf},
}

@inproceedings{damas_principal_1982,
	title = {Principal type-schemes for functional programs},
	booktitle = {Proceedings of the 9th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Damas, Luis and Milner, Robin},
	year = {1982},
	keywords = {to-read},
	pages = {207--212},
	file = {Damas and Milner - 1982 - Principal type-schemes for functional programs.pdf:/Users/timwhiting/Zotero/storage/VGF8QRXU/Damas and Milner - 1982 - Principal type-schemes for functional programs.pdf:application/pdf;Damas_Milner_1982_Principal type-schemes for functional programs.pdf:/Users/timwhiting/Zotero/storage/Z8YHM369/Damas_Milner_1982_Principal type-schemes for functional programs.pdf:application/pdf},
}

@article{stanley_generatingfunctionology_1990,
	title = {Generatingfunctionology. by herbert swilf},
	volume = {97},
	number = {9},
	journal = {The American Mathematical Monthly},
	author = {Stanley, Richard P},
	year = {1990},
	note = {Publisher: Taylor \& Francis},
	pages = {864--866},
}

@inproceedings{jones_hindley-milner_1995,
	title = {From {Hindley}-{Milner} types to first-class structures},
	booktitle = {Proceedings of the {Haskell} {Workshop}},
	author = {Jones, Mark P},
	year = {1995},
	keywords = {to-read},
}

@inproceedings{yang_fantastic_2022,
	title = {Fantastic {Morphisms} and {Where} to {Find} {Them}: {A} {Guide} to {Recursion} {Schemes}},
	booktitle = {Mathematics of {Program} {Construction}: 14th {International} {Conference}, {MPC} 2022, {Tbilisi}, {Georgia}, {September} 26–28, 2022, {Proceedings}},
	publisher = {Springer International Publishing Cham},
	author = {Yang, Zhixuan and Wu, Nicolas},
	year = {2022},
	keywords = {to-read},
	pages = {222--267},
	file = {Yang and Wu - 2022 - Fantastic Morphisms and Where to Find Them A Guid.pdf:/Users/timwhiting/Zotero/storage/LSEUZGYS/Yang and Wu - 2022 - Fantastic Morphisms and Where to Find Them A Guid.pdf:application/pdf},
}

@article{chang_dependent_2019,
	title = {Dependent type systems as macros},
	volume = {4},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Chang, Stephen and Ballantyne, Michael and Turner, Milo and Bowman, William J},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--29},
	file = {Chang et al. - 2019 - Dependent type systems as macros.pdf:/Users/timwhiting/Zotero/storage/D6EM7QM5/Chang et al. - 2019 - Dependent type systems as macros.pdf:application/pdf},
}

@article{mcbride_dependently_2000,
	title = {Dependently typed functional programs and their proofs},
	author = {McBride, Conor},
	year = {2000},
	note = {Publisher: University of Edinburgh. College of Science and Engineering. School of …},
	keywords = {to-read},
}

@article{hindley_principal_1969,
	title = {The principal type-scheme of an object in combinatory logic},
	volume = {146},
	journal = {Transactions of the american mathematical society},
	author = {Hindley, Roger},
	year = {1969},
	note = {Publisher: JSTOR},
	keywords = {to-read},
	pages = {29--60},
	file = {Hindley - 1969 - The principal type-scheme of an object in combinat.pdf:/Users/timwhiting/Zotero/storage/UHHR4S2B/Hindley - 1969 - The principal type-scheme of an object in combinat.pdf:application/pdf},
}

@article{milner_theory_1978,
	title = {A theory of type polymorphism in programming},
	volume = {17},
	number = {3},
	journal = {Journal of computer and system sciences},
	author = {Milner, Robin},
	year = {1978},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {348--375},
	file = {Milner - 1978 - A theory of type polymorphism in programming.pdf:/Users/timwhiting/Zotero/storage/Z38GG6VU/Milner - 1978 - A theory of type polymorphism in programming.pdf:application/pdf},
}

@article{huet_zipper_1997,
	title = {The zipper},
	volume = {7},
	number = {5},
	journal = {Journal of functional programming},
	author = {Huet, Gérard},
	year = {1997},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {549--554},
}

@article{leijen_what_nodate,
	title = {What {About} the {Integer} {Numbers}?},
	author = {LEIJEN, DAAN},
	keywords = {to-read},
	file = {LEIJEN - What About the Integer Numbers.pdf:/Users/timwhiting/Zotero/storage/WHQJLT29/LEIJEN - What About the Integer Numbers.pdf:application/pdf},
}

@article{mcbride_derivative_2001,
	title = {The derivative of a regular type is its type of one-hole contexts},
	journal = {Unpublished manuscript},
	author = {McBride, Conor},
	year = {2001},
	note = {Publisher: Citeseer},
	keywords = {to-read},
	pages = {74--88},
}

@article{zabalza_novel_2016,
	title = {Novel segmented stacked autoencoder for effective dimensionality reduction and feature extraction in hyperspectral imaging},
	volume = {185},
	journal = {Neurocomputing},
	author = {Zabalza, Jaime and Ren, Jinchang and Zheng, Jiangbin and Zhao, Huimin and Qing, Chunmei and Yang, Zhijing and Du, Peijun and Marshall, Stephen},
	year = {2016},
	note = {Publisher: Elsevier},
	pages = {1--10},
}

@article{biernacki_abstracting_2019,
	title = {Abstracting algebraic effects},
	volume = {3},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Biernacki, Dariusz and Piróg, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--28},
}

@techreport{leijen_algebraic_2018,
	title = {Algebraic effect handlers with resources and deep finalization},
	institution = {Technical Report MSR-TR-2018-10. Microsoft Research},
	author = {Leijen, Daan},
	year = {2018},
	keywords = {to-read},
	file = {Leijen - 2018 - Algebraic effect handlers with resources and deep .pdf:/Users/timwhiting/Zotero/storage/X9UHKZHS/Leijen - 2018 - Algebraic effect handlers with resources and deep .pdf:application/pdf},
}

@article{xie_first-class_2022,
	title = {First-class names for effect handlers},
	volume = {6},
	number = {OOPSLA2},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Xie, Ningning and Cong, Youyou and Ikemori, Kazuki and Leijen, Daan},
	year = {2022},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {30--59},
	file = {Xie et al_2022_First-class names for effect handlers.pdf:/Users/timwhiting/Zotero/storage/E2AULZYI/Xie et al_2022_First-class names for effect handlers.pdf:application/pdf;Xie et al_2022_First-class names for effect handlers2.pdf:/Users/timwhiting/Zotero/storage/93BGXZAT/Xie et al_2022_First-class names for effect handlers2.pdf:application/pdf},
}

@article{xie_generalized_2021,
	title = {Generalized evidence passing for effect handlers: efficient compilation of effect handlers to {C}},
	volume = {5},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Xie, Ningning and Leijen, Daan},
	year = {2021},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--30},
}

@inproceedings{leijen_type_2017,
	title = {Type directed compilation of row-typed algebraic effects},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} {Symposium} on {Principles} of {Programming} {Languages}},
	author = {Leijen, Daan},
	year = {2017},
	keywords = {to-read},
	pages = {486--499},
	file = {Leijen - 2017 - Type directed compilation of row-typed algebraic e.pdf:/Users/timwhiting/Zotero/storage/CXW23ZCF/Leijen - 2017 - Type directed compilation of row-typed algebraic e.pdf:application/pdf},
}

@inproceedings{leijen_implementing_2017,
	title = {Implementing {Algebraic} {Effects} in {C}: “{Monads} for {Free} in {C}”},
	booktitle = {Programming {Languages} and {Systems}: 15th {Asian} {Symposium}, {APLAS} 2017, {Suzhou}, {China}, {November} 27-29, 2017, {Proceedings} 15},
	publisher = {Springer International Publishing},
	author = {Leijen, Daan},
	year = {2017},
	keywords = {to-read},
	pages = {339--363},
	file = {Leijen - 2017 - Implementing Algebraic Effects in C “Monads for F.pdf:/Users/timwhiting/Zotero/storage/JXYHSFZJ/Leijen - 2017 - Implementing Algebraic Effects in C “Monads for F.pdf:application/pdf},
}

@article{xie_generalized_2021-1,
	title = {Generalized evidence passing for effect handlers},
	journal = {Microsoft Research. Extended version with proofs},
	author = {Xie, Ningning and Leijen, Daan},
	year = {2021},
	keywords = {to-read},
	file = {Xie_Leijen_2021_Generalized evidence passing for effect handlers.pdf:/Users/timwhiting/Zotero/storage/VPJQQIUE/Xie_Leijen_2021_Generalized evidence passing for effect handlers.pdf:application/pdf;Xie_Leijen_2021_Generalized evidence passing for effect handlers2.pdf:/Users/timwhiting/Zotero/storage/F7LSKAZN/Xie_Leijen_2021_Generalized evidence passing for effect handlers2.pdf:application/pdf;Xie_Leijen_2021_Generalized evidence passing for effect handlers3.pdf:/Users/timwhiting/Zotero/storage/VL7BN5WC/Xie_Leijen_2021_Generalized evidence passing for effect handlers3.pdf:application/pdf},
}

@inproceedings{leijen_first_2018,
	title = {First class dynamic effect handlers: {Or}, polymorphic heaps with dynamic effect handlers},
	booktitle = {Proceedings of the 3rd {ACM} {SIGPLAN} {International} {Workshop} on {Type}-{Driven} {Development}},
	author = {Leijen, Daan},
	year = {2018},
	keywords = {to-read},
	pages = {51--64},
	file = {Leijen - 2018 - First class dynamic effect handlers Or, polymorph.pdf:/Users/timwhiting/Zotero/storage/CNAZMVHK/Leijen - 2018 - First class dynamic effect handlers Or, polymorph.pdf:application/pdf},
}

@article{biernacki_logical_nodate,
	title = {Logical {Relations} for {Algebraic} {Effects}},
	author = {Biernacki, Dariusz and Piróg, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	keywords = {to-read},
}

@techreport{leijen_algebraic_2016,
	title = {Algebraic effects for functional programming},
	institution = {Technical Report. MSR-TR-2016-29. Microsoft Research technical report},
	author = {Leijen, Daan},
	year = {2016},
	keywords = {to-read},
	file = {Leijen - 2016 - Algebraic effects for functional programming.pdf:/Users/timwhiting/Zotero/storage/LH729TCN/Leijen - 2016 - Algebraic effects for functional programming.pdf:application/pdf},
}

@article{crandall_when_2020,
	title = {When autonomous agents model other agents: {An} appeal for altered judgment coupled with mouths, ears, and a little more tape},
	volume = {280},
	journal = {Artificial Intelligence},
	author = {Crandall, Jacob W},
	year = {2020},
	note = {Publisher: Elsevier},
	pages = {103219},
	file = {Crandall - 2020 - When autonomous agents model other agents An appe.pdf:/Users/timwhiting/Zotero/storage/HXXN3259/Crandall - 2020 - When autonomous agents model other agents An appe.pdf:application/pdf},
}

@inproceedings{baumeister_towards_2020,
	title = {Towards reality: smoothed analysis in computational social choice},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Autonomous} {Agents} and {Multiagent} {Systems}},
	author = {Baumeister, Dorothea and Hogrebe, Tobias and Rothe, Jörg},
	year = {2020},
	pages = {1691--1695},
}

@inproceedings{jensen_towards_2022,
	title = {Towards {Efficient} {Context}-{Sensitive} {Deliberation}},
	booktitle = {Advances in {Social} {Simulation}: {Proceedings} of the 16th {Social} {Simulation} {Conference}, 20–24 {September} 2021},
	publisher = {Springer International Publishing Cham},
	author = {Jensen, Maarten and Verhagen, Harko and Vanhée, Loïs and Dignum, Frank},
	year = {2022},
	pages = {409--421},
}

@book{robinson_topology_2005,
	title = {The topology of the 2x2 games: a new periodic table},
	volume = {3},
	publisher = {Psychology Press},
	author = {Robinson, David and Goforth, David},
	year = {2005},
}

@inproceedings{was_manipulability_2020,
	title = {The manipulability of centrality measures-an axiomatic approach},
	booktitle = {Proceedings of the 19th international conference on autonomous agents and multiagent systems},
	author = {Wąs, Tomasz and Waniek, Marcin and Rahwan, Talal and Michalak, Tomasz},
	year = {2020},
	pages = {1467--1475},
}

@misc{dignum_alignment_2021,
	title = {The {Alignment} {Problem}: {Machine} {Learning} and {Human} {Values}},
	publisher = {NATURE PORTFOLIO HEIDELBERGER PLATZ 3, BERLIN, 14197, GERMANY},
	author = {Dignum, Virginia and Christian, B},
	year = {2021},
}

@inproceedings{lobo_socially_2022,
	title = {Socially {Aware} {Interactions}: {From} {Dialogue} {Trees} to {Natural} {Language} {Dialogue} {Systems}},
	booktitle = {Chatbot {Research} and {Design}: 5th {International} {Workshop}, {CONVERSATIONS} 2021, {Virtual} {Event}, {November} 23–24, 2021, {Revised} {Selected} {Papers}},
	publisher = {Springer International Publishing Cham},
	author = {Lobo, Inês and Rato, Diogo and Prada, Rui and Dignum, Frank},
	year = {2022},
	pages = {124--140},
}

@inproceedings{malekzadeh_social_2011,
	title = {Social balance and signed network formation games},
	booktitle = {Proceedings of {KDD} workshop on {Social} {Network} {Analysis} ({SNA}-{KDD}), to appear},
	author = {Malekzadeh, Mohammad and Fazli, M and Khalilabadi, P Jalali and Rabiee, H and Safari, M},
	year = {2011},
}

@article{cisneros-velarde_signed_2020,
	title = {Signed network formation games and clustering balance},
	volume = {10},
	number = {4},
	journal = {Dynamic Games and Applications},
	author = {Cisneros-Velarde, Pedro and Bullo, Francesco},
	year = {2020},
	note = {Publisher: Springer},
	pages = {783--797},
}

@inproceedings{skibski_signed_2020,
	title = {Signed graph games: {Coalitional} games with friends, enemies and allies},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Autonomous} {Agents} and {Multiagent} {Systems}},
	author = {Skibski, Oskar and Suzuki, Takamasa and Grabowski, Tomasz and Michalak, Tomasz and Yokoo, Makoto},
	year = {2020},
	pages = {1287--1295},
}

@article{forster_expressive_2019,
	title = {On the expressive power of user-defined effects: {Effect} handlers, monadic reflection, delimited control},
	volume = {29},
	journal = {Journal of Functional Programming},
	author = {Forster, Yannick and Kammar, Ohad and Lindley, Sam and Pretnar, Matija},
	year = {2019},
	note = {Publisher: Cambridge University Press},
	pages = {e15},
	file = {Forster et al. - 2019 - On the expressive power of user-defined effects E.pdf:/Users/timwhiting/Zotero/storage/CWHVITUF/Forster et al. - 2019 - On the expressive power of user-defined effects E.pdf:application/pdf},
}

@inproceedings{ullrich_counting_2019,
	title = {Counting immutable beans: {Reference} counting optimized for purely functional programming},
	booktitle = {Proceedings of the 31st {Symposium} on {Implementation} and {Application} of {Functional} {Languages}},
	author = {Ullrich, Sebastian and de Moura, Leonardo},
	year = {2019},
	keywords = {to-read},
	pages = {1--12},
	file = {Ullrich and de Moura - 2019 - Counting immutable beans Reference counting optim.pdf:/Users/timwhiting/Zotero/storage/TDH24SCC/Ullrich and de Moura - 2019 - Counting immutable beans Reference counting optim.pdf:application/pdf},
}

@article{germane_deletion_2014,
	title = {Deletion: {The} curse of the red-black tree},
	volume = {24},
	number = {4},
	journal = {Journal of Functional Programming},
	author = {Germane, Kimball and Might, Matthew},
	year = {2014},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {423--433},
	file = {Germane and Might - 2014 - Deletion The curse of the red-black tree.pdf:/Users/timwhiting/Zotero/storage/TANYSSPJ/Germane and Might - 2014 - Deletion The curse of the red-black tree.pdf:application/pdf},
}

@inproceedings{vandenbroucke_fixing_2015,
	title = {Fixing non-determinism},
	booktitle = {Proceedings of the 27th {Symposium} on the {Implementation} and {Application} of {Functional} {Programming} {Languages}},
	author = {Vandenbroucke, Alexander and Schrijvers, Tom and Piessens, Frank},
	year = {2015},
	keywords = {to-read},
	pages = {1--12},
	file = {Vandenbroucke et al. - 2015 - Fixing non-determinism.pdf:/Users/timwhiting/Zotero/storage/26QKDDDK/Vandenbroucke et al. - 2015 - Fixing non-determinism.pdf:application/pdf},
}

@article{pretnar_handling_2013,
	title = {Handling algebraic effects},
	volume = {9},
	journal = {Logical methods in computer science},
	author = {Pretnar, Matija and Plotkin, Gordon D},
	year = {2013},
	note = {Publisher: Episciences. org},
	keywords = {to-read},
	file = {Pretnar and Plotkin - 2013 - Handling algebraic effects.pdf:/Users/timwhiting/Zotero/storage/3D5MGSV6/Pretnar and Plotkin - 2013 - Handling algebraic effects.pdf:application/pdf;Pretnar_Plotkin_2013_Handling algebraic effects.pdf:/Users/timwhiting/Zotero/storage/GNGWHCZT/Pretnar_Plotkin_2013_Handling algebraic effects.pdf:application/pdf},
}

@inproceedings{oudah_learning_2015,
	title = {Learning to interact with a human partner},
	booktitle = {Proceedings of the tenth annual acm/ieee international conference on human-robot interaction},
	author = {Oudah, Mayada and Babushkin, Vahan and Chenlinangjia, Tennom and Crandall, Jacob W},
	year = {2015},
	pages = {311--318},
	file = {Oudah et al. - 2015 - Learning to interact with a human partner.pdf:/Users/timwhiting/Zotero/storage/93EJPZ9P/Oudah et al. - 2015 - Learning to interact with a human partner.pdf:application/pdf},
}

@inproceedings{oudah_how_2018,
	title = {How {AI} wins friends and influences people in repeated games with cheap talk},
	volume = {32},
	booktitle = {Proceedings of the {AAAI} {Conference} on {Artificial} {Intelligence}},
	author = {Oudah, Mayada and Rahwan, Talal and Crandall, Tawna and Crandall, Jacob},
	year = {2018},
	note = {Issue: 1},
	file = {Oudah et al. - 2018 - How AI wins friends and influences people in repea.pdf:/Users/timwhiting/Zotero/storage/8ZQKE9TK/Oudah et al. - 2018 - How AI wins friends and influences people in repea.pdf:application/pdf},
}

@incollection{littman_markov_1994,
	title = {Markov games as a framework for multi-agent reinforcement learning},
	booktitle = {Machine learning proceedings 1994},
	publisher = {Elsevier},
	author = {Littman, Michael L},
	year = {1994},
	pages = {157--163},
}

@article{cabitza_need_2021,
	title = {The need to move away from agential-{AI}: {Empirical} investigations, useful concepts and open issues},
	volume = {155},
	journal = {International Journal of Human-Computer Studies},
	author = {Cabitza, Federico and Campagner, Andrea and Simone, Carla},
	year = {2021},
	note = {Publisher: Elsevier},
	pages = {102696},
}

@inproceedings{brady_programming_2013,
	title = {Programming and reasoning with algebraic effects and dependent types},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on {Functional} programming},
	author = {Brady, Edwin},
	year = {2013},
	keywords = {to-read},
	pages = {133--144},
	file = {Brady - 2013 - Programming and reasoning with algebraic effects a.pdf:/Users/timwhiting/Zotero/storage/MQA6XRU9/Brady - 2013 - Programming and reasoning with algebraic effects a.pdf:application/pdf},
}

@article{krishnaswami_higher-order_2013,
	title = {Higher-order functional reactive programming without spacetime leaks},
	volume = {48},
	number = {9},
	journal = {ACM SIGPLAN Notices},
	author = {Krishnaswami, Neelakantan R},
	year = {2013},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {221--232},
	file = {Krishnaswami - 2013 - Higher-order functional reactive programming witho.pdf:/Users/timwhiting/Zotero/storage/BXRZDXT9/Krishnaswami - 2013 - Higher-order functional reactive programming witho.pdf:application/pdf},
}

@article{brachthauser_effects_2022,
	title = {Effects, capabilities, and boxes: from scope-based reasoning to type-based reasoning and back},
	volume = {6},
	number = {OOPSLA1},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Brachthäuser, Jonathan Immanuel and Schuster, Philipp and Lee, Edward and Boruch-Gruszecki, Aleksander},
	year = {2022},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--30},
	file = {Brachthäuser et al. - 2022 - Effects, capabilities, and boxes from scope-based.pdf:/Users/timwhiting/Zotero/storage/PLQK9YLU/Brachthäuser et al. - 2022 - Effects, capabilities, and boxes from scope-based.pdf:application/pdf},
}

@inproceedings{rafkind_honu_2012,
	title = {Honu: syntactic extension for algebraic notation through enforestation},
	booktitle = {Proceedings of the 11th {International} {Conference} on {Generative} {Programming} and {Component} {Engineering}},
	author = {Rafkind, Jon and Flatt, Matthew},
	year = {2012},
	keywords = {to-read},
	pages = {122--131},
	file = {Rafkind and Flatt - 2012 - Honu syntactic extension for algebraic notation t.pdf:/Users/timwhiting/Zotero/storage/K42LLPZU/Rafkind and Flatt - 2012 - Honu syntactic extension for algebraic notation t.pdf:application/pdf},
}

@article{balik_algebraic_nodate,
	title = {Algebraic {Effect} {Instance} {Scopes}},
	author = {Balik, Patrycja},
	keywords = {to-read},
	file = {Balik - Algebraic Effect Instance Scopes.pdf:/Users/timwhiting/Zotero/storage/6VKXR43F/Balik - Algebraic Effect Instance Scopes.pdf:application/pdf},
}

@inproceedings{asai_functional_2010,
	title = {Functional derivation of a virtual machine for delimited continuations},
	booktitle = {Proceedings of the 12th international {ACM} {SIGPLAN} symposium on {Principles} and practice of declarative programming},
	author = {Asai, Kenichi and Kitani, Arisa},
	year = {2010},
	keywords = {to-read},
	pages = {87--98},
	file = {Asai and Kitani - 2010 - Functional derivation of a virtual machine for del.pdf:/Users/timwhiting/Zotero/storage/NTCVZ7DW/Asai and Kitani - 2010 - Functional derivation of a virtual machine for del.pdf:application/pdf},
}

@article{asai_typing_2009,
	title = {On typing delimited continuations: three new solutions to the printf problem},
	volume = {22},
	journal = {Higher-order and symbolic computation},
	author = {Asai, Kenichi},
	year = {2009},
	note = {Publisher: Springer},
	keywords = {to-read},
	pages = {275--291},
	file = {Asai_2009_On typing delimited continuations.pdf:/Users/timwhiting/Zotero/storage/ID8GE6HQ/Asai_2009_On typing delimited continuations.pdf:application/pdf},
}

@article{darais_abstracting_2017,
	title = {Abstracting {Definitional} {Interpreters} ({Functional} {Pearl})},
	volume = {1},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Darais, David and Labich, Nicholas and Nguyen, Phúc C and Van Horn, David},
	year = {2017},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--25},
	file = {Darais et al. - 2017 - Abstracting Definitional Interpreters (Functional .pdf:/Users/timwhiting/Zotero/storage/R8DX6CRS/Darais et al. - 2017 - Abstracting Definitional Interpreters (Functional .pdf:application/pdf},
}

@inproceedings{might_improving_2006,
	title = {Improving flow analyses via Γ{CFA}: {Abstract} garbage collection and counting},
	booktitle = {Proceedings of the eleventh {ACM} {SIGPLAN} international conference on {Functional} programming},
	author = {Might, Matthew and Shivers, Olin},
	year = {2006},
	keywords = {to-read},
	pages = {13--25},
	file = {Might and Shivers - 2006 - Improving flow analyses via ΓCFA Abstract garbage.pdf:/Users/timwhiting/Zotero/storage/J4ZRNJJB/Might and Shivers - 2006 - Improving flow analyses via ΓCFA Abstract garbage.pdf:application/pdf},
}

@inproceedings{gilray_allocation_2016,
	title = {Allocation characterizes polyvariance: a unified methodology for polyvariant control-flow analysis},
	booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	author = {Gilray, Thomas and Adams, Michael D and Might, Matthew},
	year = {2016},
	keywords = {to-read},
	pages = {407--420},
	file = {Gilray et al. - 2016 - Allocation characterizes polyvariance a unified m.pdf:/Users/timwhiting/Zotero/storage/5T8HX8Q3/Gilray et al. - 2016 - Allocation characterizes polyvariance a unified m.pdf:application/pdf},
}

@article{darais_galois_2015,
	title = {Galois transformers and modular abstract interpreters: reusable metatheory for program analysis},
	volume = {50},
	number = {10},
	journal = {ACM SIGPLAN Notices},
	author = {Darais, David and Might, Matthew and Van Horn, David},
	year = {2015},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {552--571},
	file = {Darais et al. - 2015 - Galois transformers and modular abstract interpret.pdf:/Users/timwhiting/Zotero/storage/TSFJICQD/Darais et al. - 2015 - Galois transformers and modular abstract interpret.pdf:application/pdf},
}

@book{felleisen_semantics_2009,
	title = {Semantics engineering with {PLT} {Redex}},
	publisher = {Mit Press},
	author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew},
	year = {2009},
	keywords = {to-read},
}

@book{shivers_control-flow_1991,
	title = {Control-flow analysis of higher-order languages or taming lambda},
	publisher = {Carnegie Mellon University},
	author = {Shivers, Olin Grigsby},
	year = {1991},
	keywords = {to-read},
	file = {Shivers - 1991 - Control-flow analysis of higher-order languages or.pdf:/Users/timwhiting/Zotero/storage/QYH7P4UJ/Shivers - 1991 - Control-flow analysis of higher-order languages or.pdf:application/pdf},
}

@inproceedings{hillerstrom_liberating_2016,
	title = {Liberating effects with rows and handlers},
	booktitle = {Proceedings of the 1st {International} {Workshop} on {Type}-{Driven} {Development}},
	author = {Hillerström, Daniel and Lindley, Sam},
	year = {2016},
	keywords = {to-read},
	pages = {15--27},
	file = {Hillerström and Lindley - 2016 - Liberating effects with rows and handlers.pdf:/Users/timwhiting/Zotero/storage/KE2GBICZ/Hillerström and Lindley - 2016 - Liberating effects with rows and handlers.pdf:application/pdf},
}

@inproceedings{xie_consistent_2018,
	title = {Consistent subtyping for all},
	booktitle = {Programming {Languages} and {Systems}: 27th {European} {Symposium} on {Programming}, {ESOP} 2018, {Held} as {Part} of the {European} {Joint} {Conferences} on {Theory} and {Practice} of {Software}, {ETAPS} 2018, {Thessaloniki}, {Greece}, {April} 14-20, 2018, {Proceedings} 27},
	publisher = {Springer},
	author = {Xie, Ningning and Bi, Xuan and Oliveira, Bruno C d S},
	year = {2018},
	keywords = {to-read},
	pages = {3--30},
	file = {Xie et al. - 2018 - Consistent subtyping for all.pdf:/Users/timwhiting/Zotero/storage/PV5QPZUL/Xie et al. - 2018 - Consistent subtyping for all.pdf:application/pdf},
}

@inproceedings{xie_let_2018,
	title = {Let arguments go first},
	booktitle = {Programming {Languages} and {Systems}: 27th {European} {Symposium} on {Programming}, {ESOP} 2018, {Held} as {Part} of the {European} {Joint} {Conferences} on {Theory} and {Practice} of {Software}, {ETAPS} 2018, {Thessaloniki}, {Greece}, {April} 14-20, 2018, {Proceedings} 27},
	publisher = {Springer},
	author = {Xie, Ningning and Oliveira, Bruno C d S},
	year = {2018},
	keywords = {to-read},
	pages = {272--299},
	file = {Xie and Oliveira - 2018 - Let arguments go first.pdf:/Users/timwhiting/Zotero/storage/7ABW6GD2/Xie and Oliveira - 2018 - Let arguments go first.pdf:application/pdf},
}

@inproceedings{flatt_units_1998,
	title = {Units: {Cool} modules for {HOT} languages},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1998 conference on {Programming} language design and implementation},
	author = {Flatt, Matthew and Felleisen, Matthias},
	year = {1998},
	keywords = {to-read},
	pages = {236--248},
	file = {Flatt and Felleisen - 1998 - Units Cool modules for HOT languages.pdf:/Users/timwhiting/Zotero/storage/MDFWS8LG/Flatt and Felleisen - 1998 - Units Cool modules for HOT languages.pdf:application/pdf},
}

@article{serrano_quick_2020,
	title = {A quick look at impredicativity},
	volume = {4},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Serrano, Alejandro and Hage, Jurriaan and Peyton Jones, Simon and Vytiniotis, Dimitrios and {others}},
	year = {2020},
	keywords = {to-read},
	pages = {1--29},
	file = {Serrano et al. - 2020 - A quick look at impredicativity.pdf:/Users/timwhiting/Zotero/storage/CN96TFV3/Serrano et al. - 2020 - A quick look at impredicativity.pdf:application/pdf},
}

@inproceedings{leijen_flexible_2009,
	title = {Flexible types: robust type inference for first-class polymorphism},
	booktitle = {Proceedings of the 36th annual {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Leijen, Daan},
	year = {2009},
	keywords = {to-read},
	pages = {66--77},
	file = {Leijen - 2009 - Flexible types robust type inference for first-cl.pdf:/Users/timwhiting/Zotero/storage/GJAMNBMK/Leijen - 2009 - Flexible types robust type inference for first-cl.pdf:application/pdf},
}

@article{germane_posteriori_2017,
	title = {A posteriori environment analysis with pushdown {Delta} {CFA}},
	volume = {52},
	number = {1},
	journal = {ACM SIGPLAN Notices},
	author = {Germane, Kimball and Might, Matthew},
	year = {2017},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {19--31},
	file = {Germane and Might - 2017 - A posteriori environment analysis with pushdown De.pdf:/Users/timwhiting/Zotero/storage/7K9B8YPJ/Germane and Might - 2017 - A posteriori environment analysis with pushdown De.pdf:application/pdf},
}

@article{germane_newly-single_2021,
	title = {Newly-single and loving it: improving higher-order must-alias analysis with heap fragments},
	volume = {5},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Germane, Kimball and McCarthy, Jay},
	year = {2021},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--28},
	file = {Germane and McCarthy - 2021 - Newly-single and loving it improving higher-order.pdf:/Users/timwhiting/Zotero/storage/IF9KQVKL/Germane and McCarthy - 2021 - Newly-single and loving it improving higher-order.pdf:application/pdf},
}

@inproceedings{germane_demand_2019,
	title = {Demand control-flow analysis},
	booktitle = {Verification, {Model} {Checking}, and {Abstract} {Interpretation}: 20th {International} {Conference}, {VMCAI} 2019, {Cascais}, {Portugal}, {January} 13–15, 2019, {Proceedings} 20},
	publisher = {Springer},
	author = {Germane, Kimball and McCarthy, Jay and Adams, Michael D and Might, Matthew},
	year = {2019},
	keywords = {to-read},
	pages = {226--246},
	file = {Germane et al_2019_Demand control-flow analysis.pdf:/Users/timwhiting/Zotero/storage/42J6WM6A/Germane et al_2019_Demand control-flow analysis.pdf:application/pdf;Germane et al_2019_Demand control-flow analysis2.pdf:/Users/timwhiting/Zotero/storage/W8HXVWGV/Germane et al_2019_Demand control-flow analysis2.pdf:application/pdf},
}

@inproceedings{germane_liberate_2020,
	title = {Liberate {Abstract} {Garbage} {Collection} from the {Stack} by {Decomposing} the {Heap}},
	booktitle = {Programming {Languages} and {Systems}: 29th {European} {Symposium} on {Programming}, {ESOP} 2020, {Held} as {Part} of the {European} {Joint} {Conferences} on {Theory} and {Practice} of {Software}, {ETAPS} 2020, {Dublin}, {Ireland}, {April} 25–30, 2020, {Proceedings} 29},
	publisher = {Springer International Publishing},
	author = {Germane, Kimball and Adams, Michael D},
	year = {2020},
	keywords = {to-read},
	pages = {197--223},
	file = {Germane and Adams - 2020 - Liberate Abstract Garbage Collection from the Stac.pdf:/Users/timwhiting/Zotero/storage/ZEVNM9KE/Germane and Adams - 2020 - Liberate Abstract Garbage Collection from the Stac.pdf:application/pdf},
}

@inproceedings{germane_relatively_2019,
	title = {Relatively {Complete} {Pushdown} {Analysis} of {Escape} {Continuations}},
	booktitle = {Verification, {Model} {Checking}, and {Abstract} {Interpretation}: 20th {International} {Conference}, {VMCAI} 2019, {Cascais}, {Portugal}, {January} 13–15, 2019, {Proceedings}},
	publisher = {Springer},
	author = {Germane, Kimball and Might, Matthew},
	year = {2019},
	keywords = {to-read},
	pages = {205--225},
	file = {Germane and Might - 2019 - Relatively Complete Pushdown Analysis of Escape Co.pdf:/Users/timwhiting/Zotero/storage/RIM4Y4X9/Germane and Might - 2019 - Relatively Complete Pushdown Analysis of Escape Co.pdf:application/pdf},
}

@inproceedings{leijen_madoko_2015,
	title = {Madoko: {Scholarly} documents for the {Web}},
	booktitle = {Proceedings of the 2015 {ACM} {Symposium} on {Document} {Engineering}},
	author = {Leijen, Daan},
	year = {2015},
	keywords = {to-read},
	pages = {129--132},
	file = {Leijen - 2015 - Madoko Scholarly documents for the Web.pdf:/Users/timwhiting/Zotero/storage/X2PHMUAY/Leijen - 2015 - Madoko Scholarly documents for the Web.pdf:application/pdf},
}

@article{loh_tutorial_2010,
	title = {A tutorial implementation of a dependently typed lambda calculus},
	volume = {102},
	number = {2},
	journal = {Fundamenta informaticae},
	author = {Löh, Andres and McBride, Conor and Swierstra, Wouter},
	year = {2010},
	note = {Publisher: IOS Press},
	keywords = {to-read},
	pages = {177--207},
	file = {Löh et al. - 2010 - A tutorial implementation of a dependently typed l.pdf:/Users/timwhiting/Zotero/storage/HTQWFEGL/Löh et al. - 2010 - A tutorial implementation of a dependently typed l.pdf:application/pdf},
}

@inproceedings{wadler_linear_1990,
	title = {Linear types can change the world!},
	volume = {3},
	booktitle = {Programming concepts and methods},
	publisher = {Citeseer},
	author = {Wadler, Philip},
	year = {1990},
	note = {Issue: 4},
	keywords = {to-read},
	pages = {5},
	file = {Wadler - 1990 - Linear types can change the world!.pdf:/Users/timwhiting/Zotero/storage/T9LPNQGB/Wadler - 1990 - Linear types can change the world!.pdf:application/pdf},
}

@inproceedings{jensen_remedying_2012,
	address = {New York, NY, USA},
	series = {{ISSTA} 2012},
	title = {Remedying the {Eval} {That} {Men} {Do}},
	isbn = {978-1-4503-1454-1},
	url = {https://doi.org/10.1145/2338965.2336758},
	doi = {10.1145/2338965.2336758},
	abstract = {A range of static analysis tools and techniques have been developed in recent years with the aim of helping JavaScript web application programmers produce code that is more robust, safe, and efficient. However, as shown in a previous large-scale study, many web applications use the JavaScript eval function to dynamically construct code from text strings in ways that obstruct existing static analyses. As a consequence, the analyses either fail to reason about the web applications or produce unsound or useless results. We present an approach to soundly and automatically transform many common uses of eval into other language constructs to enable sound static analysis of web applications. By eliminating calls to eval, we expand the applicability of static analysis for JavaScript web applications in general. The transformation we propose works by incorporating a refactoring technique into a dataflow analyzer. We report on our experimental results with a small collection of programming patterns extracted from popular web sites. Although there are inevitably cases where the transformation must give up, our technique succeeds in eliminating many nontrivial occurrences of eval.},
	booktitle = {Proceedings of the 2012 {International} {Symposium} on {Software} {Testing} and {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Jensen, Simon Holm and Jonsson, Peter A. and Møller, Anders},
	year = {2012},
	note = {event-place: Minneapolis, MN, USA},
	keywords = {to-read},
	pages = {34--44},
}

@article{hillerstrom_asymptotic_nodate,
	title = {Asymptotic {Speedup} via {Effect} {Handlers}},
	author = {HILLERSTRÖM, DANIEL and LINDLEY, SAM and LONGLEY, JOHN},
	keywords = {to-read},
	file = {HILLERSTRÖM et al. - Asymptotic Speedup via Effect Handlers.pdf:/Users/timwhiting/Zotero/storage/TCMGG8JR/HILLERSTRÖM et al. - Asymptotic Speedup via Effect Handlers.pdf:application/pdf},
}

@phdthesis{sullivan_essence_2018,
	type = {{PhD} {Thesis}},
	title = {The essence of codata and its implementation},
	school = {University of Oregon},
	author = {Sullivan, Zachary Joseph},
	year = {2018},
	keywords = {to-read},
}

@article{eremondi_approximate_2019,
	title = {Approximate {Normalization} for {Gradual} {Dependent} {Types}},
	volume = {3},
	url = {https://doi.org/10.1145/3341692},
	doi = {10.1145/3341692},
	abstract = {Dependent types help programmers write highly reliable code. However, this reliability comes at a cost: it can be challenging to write new prototypes in (or migrate old code to) dependently-typed programming languages. Gradual typing makes static type disciplines more flexible, so an appropriate notion of gradual dependent types could fruitfully lower this cost. However, dependent types raise unique challenges for gradual typing. Dependent typechecking involves the execution of program code, but gradually-typed code can signal runtime type errors or diverge. These runtime errors threaten the soundness guarantees that make dependent types so attractive, while divergence spoils the type-driven programming experience. This paper presents GDTL, a gradual dependently-typed language that emphasizes pragmatic dependently-typed programming. GDTL fully embeds both an untyped and dependently-typed language, and allows for smooth transitions between the two. In addition to gradual types we introduce gradual terms, which allow the user to be imprecise in type indices and to omit proof terms; runtime checks ensure type safety. To account for nontermination and failure, we distinguish between compile-time normalization and run-time execution: compile-time normalization is approximate but total, while runtime execution is exact, but may fail or diverge. We prove that GDTL has decidable typechecking and satisfies all the expected properties of gradual languages. In particular, GDTL satisfies the static and dynamic gradual guarantees: reducing type precision preserves typedness, and altering type precision does not change program behavior outside of dynamic type failures. To prove these properties, we were led to establish a novel normalization gradual guarantee that captures the monotonicity of approximate normalization with respect to imprecision.},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Eremondi, Joseph and Tanter, Éric and Garcia, Ronald},
	month = jul,
	year = {2019},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {dependent types, Gradual types, normalization, to-read},
}

@article{jeannin_cocaml_2017,
	title = {Cocaml: {Functional} programming with regular coinductive types},
	volume = {150},
	number = {3-4},
	journal = {Fundamenta Informaticae},
	author = {Jeannin, Jean-Baptiste and Kozen, Dexter and Silva, Alexandra},
	year = {2017},
	note = {Publisher: IOS Press},
	keywords = {to-read},
	pages = {347--377},
}

@article{jacobs_tutorial_1997,
	title = {A tutorial on (co) algebras and (co) induction},
	volume = {62},
	journal = {Bulletin-European Association for Theoretical Computer Science},
	author = {Jacobs, Bart and Rutten, Jan},
	year = {1997},
	note = {Publisher: Citeseer},
	keywords = {to-read},
	pages = {222--259},
	file = {Jacobs and Rutten - 1997 - A tutorial on (co) algebras and (co) induction.pdf:/Users/timwhiting/Zotero/storage/MFV372GB/Jacobs and Rutten - 1997 - A tutorial on (co) algebras and (co) induction.pdf:application/pdf},
}

@inproceedings{blanchette_truly_2014,
	title = {Truly modular (co) datatypes for {Isabelle}/{HOL}},
	booktitle = {Interactive {Theorem} {Proving}: 5th {International} {Conference}, {ITP} 2014, {Held} as {Part} of the {Vienna} {Summer} of {Logic}, {VSL} 2014, {Vienna}, {Austria}, {July} 14-17, 2014. {Proceedings} 5},
	publisher = {Springer},
	author = {Blanchette, Jasmin Christian and Hölzl, Johannes and Lochbihler, Andreas and Panny, Lorenz and Popescu, Andrei and Traytel, Dmitriy},
	year = {2014},
	keywords = {to-read},
	pages = {93--110},
}

@article{abel_copatterns_2013,
	title = {Copatterns: {Programming} infinite structures by observations},
	volume = {48},
	number = {1},
	journal = {ACM SIGPLAN Notices},
	author = {Abel, Andreas and Pientka, Brigitte and Thibodeau, David and Setzer, Anton},
	year = {2013},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {27--38},
}

@book{filinski_declarative_1989,
	title = {Declarative continuations and categorical duality},
	publisher = {Citeseer},
	author = {Filinski, Andrzej},
	year = {1989},
	keywords = {to-read},
	file = {Filinski - 1989 - Declarative continuations and categorical duality.pdf:/Users/timwhiting/Zotero/storage/SZN3YT7W/Filinski - 1989 - Declarative continuations and categorical duality.pdf:application/pdf},
}

@inproceedings{downen_computational_2020,
	title = {A computational understanding of classical (co) recursion},
	booktitle = {Proceedings of the 22nd {International} {Symposium} on {Principles} and {Practice} of {Declarative} {Programming}},
	author = {Downen, Paul and Ariola, Zena M},
	year = {2020},
	keywords = {to-read},
	pages = {1--13},
	file = {Downen and Ariola - 2020 - A computational understanding of classical (co) re.pdf:/Users/timwhiting/Zotero/storage/7DJYN3R9/Downen and Ariola - 2020 - A computational understanding of classical (co) re.pdf:application/pdf},
}

@article{downen_classical_2021,
	title = {Classical ({Co}) {Recursion}: {Programming}},
	journal = {arXiv preprint arXiv:2103.06913},
	author = {Downen, Paul and Ariola, Zena M},
	year = {2021},
	keywords = {to-read},
	file = {Downen and Ariola - 2021 - Classical (Co) Recursion Programming.pdf:/Users/timwhiting/Zotero/storage/W899RTIX/Downen and Ariola - 2021 - Classical (Co) Recursion Programming.pdf:application/pdf},
}

@article{wei_compiling_2020,
	title = {Compiling symbolic execution with staging and algebraic effects},
	volume = {4},
	number = {OOPSLA},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Wei, Guannan and Bračevac, Oliver and Tan, Shangyin and Rompf, Tiark},
	year = {2020},
	keywords = {to-read},
	file = {Wei et al. - 2020 - Compiling symbolic execution with staging and alge.pdf:/Users/timwhiting/Zotero/storage/XEHP8UJU/Wei et al. - 2020 - Compiling symbolic execution with staging and alge.pdf:application/pdf},
}

@article{petricek_coeffects_2014,
	title = {Coeffects: a calculus of context-dependent computation},
	volume = {49},
	number = {9},
	journal = {ACM SIGPLAN Notices},
	author = {Petricek, Tomas and Orchard, Dominic and Mycroft, Alan},
	year = {2014},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {123--135},
	file = {Petricek et al. - 2014 - Coeffects a calculus of context-dependent computa.pdf:/Users/timwhiting/Zotero/storage/U6M46G66/Petricek et al. - 2014 - Coeffects a calculus of context-dependent computa.pdf:application/pdf},
}

@inproceedings{meijer_functional_1991,
	title = {Functional {Programming} with {Bananas}, {Lenses}, {Envelopes} and {Barbed} {Wire}.},
	volume = {91},
	booktitle = {{FPCA}},
	author = {Meijer, Erik and Fokkinga, Maarten M and Paterson, Ross},
	year = {1991},
	keywords = {to-read},
	pages = {124--144},
	file = {Meijer et al. - 1991 - Functional Programming with Bananas, Lenses, Envel.pdf:/Users/timwhiting/Zotero/storage/6ZQUQ9WJ/Meijer et al. - 1991 - Functional Programming with Bananas, Lenses, Envel.pdf:application/pdf},
}

@inproceedings{fachinetti_set-based_2020,
	title = {A {Set}-{Based} {Context} {Model} for {Program} {Analysis}},
	booktitle = {Programming {Languages} and {Systems}: 18th {Asian} {Symposium}, {APLAS} 2020, {Fukuoka}, {Japan}, {November} 30–{December} 2, 2020, {Proceedings} 18},
	publisher = {Springer},
	author = {Fachinetti, Leandro and Palmer, Zachary and Smith, Scott F and Wu, Ke and Yorihiro, Ayaka},
	year = {2020},
	keywords = {to-read},
	pages = {3--24},
	file = {Fachinetti et al. - 2020 - A Set-Based Context Model for Program Analysis.pdf:/Users/timwhiting/Zotero/storage/C2WBJBED/Fachinetti et al. - 2020 - A Set-Based Context Model for Program Analysis.pdf:application/pdf},
}

@article{palmer_higher-order_2020,
	title = {Higher-order demand-driven symbolic evaluation.},
	volume = {4},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Palmer, Zachary and Park, Theodore and Smith, Scott F and Weng, Shiwei},
	year = {2020},
	keywords = {to-read},
	pages = {102--1},
	file = {Palmer et al. - 2020 - Higher-order demand-driven symbolic evaluation..pdf:/Users/timwhiting/Zotero/storage/J95XK7NY/Palmer et al. - 2020 - Higher-order demand-driven symbolic evaluation..pdf:application/pdf},
}

@article{facchinetti_higher-order_2019,
	title = {Higher-order demand-driven program analysis},
	volume = {41},
	number = {3},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Facchinetti, Leandro and Palmer, Zachary and Smith, Scott},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--53},
	file = {Facchinetti et al. - 2019 - Higher-order demand-driven program analysis.pdf:/Users/timwhiting/Zotero/storage/E6MCWIRW/Facchinetti et al. - 2019 - Higher-order demand-driven program analysis.pdf:application/pdf},
}

@inproceedings{might_resolving_2010,
	title = {Resolving and exploiting the k-{CFA} paradox: illuminating functional vs. object-oriented program analysis},
	booktitle = {Proceedings of the 31st {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	author = {Might, Matthew and Smaragdakis, Yannis and Van Horn, David},
	year = {2010},
	keywords = {to-read},
	pages = {305--315},
	file = {Might et al_2010_Resolving and exploiting the k-CFA paradox.pdf:/Users/timwhiting/Zotero/storage/QGKDL6A3/Might et al_2010_Resolving and exploiting the k-CFA paradox.pdf:application/pdf;Might et al_2010_Resolving and exploiting the k-CFA paradox2.pdf:/Users/timwhiting/Zotero/storage/A9C57PHW/Might et al_2010_Resolving and exploiting the k-CFA paradox2.pdf:application/pdf},
}

@book{nielson_principles_2015,
	title = {Principles of program analysis},
	publisher = {Springer},
	author = {Nielson, Flemming and Nielson, Hanne R and Hankin, Chris},
	year = {2015},
	keywords = {to-read},
}

@inproceedings{freeman_refinement_1991,
	title = {Refinement types for {ML}},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1991 conference on {Programming} language design and implementation},
	author = {Freeman, Tim and Pfenning, Frank},
	year = {1991},
	keywords = {to-read},
	pages = {268--277},
	file = {Freeman and Pfenning - 1991 - Refinement types for ML.pdf:/Users/timwhiting/Zotero/storage/4WTFST8W/Freeman and Pfenning - 1991 - Refinement types for ML.pdf:application/pdf},
}

@inproceedings{wolff_gradual_2011,
	title = {Gradual {Typestate}.},
	volume = {11},
	booktitle = {{ECOOP}},
	publisher = {Springer},
	author = {Wolff, Roger and Garcia, Ronald and Tanter, Éric and Aldrich, Jonathan},
	year = {2011},
	keywords = {to-read},
	pages = {459--483},
	file = {Wolff et al. - 2011 - Gradual Typestate..pdf:/Users/timwhiting/Zotero/storage/67KVSTD8/Wolff et al. - 2011 - Gradual Typestate..pdf:application/pdf},
}

@article{szabolcsi_combinatory_1992,
	title = {Combinatory grammar and projection from the lexicon},
	volume = {1192},
	journal = {Lexical matters},
	author = {Szabolcsi, Anna},
	year = {1992},
	note = {Publisher: CSLI publications Stanford},
	keywords = {to-read},
	file = {Szabolcsi - 1992 - Combinatory grammar and projection from the lexico.pdf:/Users/timwhiting/Zotero/storage/NHTBXTTN/Szabolcsi - 1992 - Combinatory grammar and projection from the lexico.pdf:application/pdf},
}

@article{midtgaard_control-flow_2012,
	title = {Control-flow analysis of functional programs},
	volume = {44},
	number = {3},
	journal = {ACM computing surveys (CSUR)},
	author = {Midtgaard, Jan},
	year = {2012},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--33},
	file = {Midtgaard - 2012 - Control-flow analysis of functional programs.pdf:/Users/timwhiting/Zotero/storage/UKV9Z9SU/Midtgaard - 2012 - Control-flow analysis of functional programs.pdf:application/pdf},
}

@article{shene_comparative_1996,
	title = {A comparative study of linked list sorting algorithms},
	volume = {3},
	number = {2},
	journal = {3C ON-LINE},
	author = {Shene, Ching-Kuang},
	year = {1996},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {4--9},
	file = {Shene - 1996 - A comparative study of linked list sorting algorit.pdf:/Users/timwhiting/Zotero/storage/6J89Q238/Shene - 1996 - A comparative study of linked list sorting algorit.pdf:application/pdf},
}

@inproceedings{quiring_3cps_2021,
	title = {{3CPS}: {The} {Design} of an {Environment}-{Focussed} {Intermediate} {Representation}},
	booktitle = {33rd {Symposium} on {Implementation} and {Application} of {Functional} {Languages}},
	author = {Quiring, Benjamin and Reppy, John and Shivers, Olin},
	year = {2021},
	pages = {20--28},
	file = {Quiring et al. - 2021 - 3CPS The Design of an Environment-Focussed Interm.pdf:/Users/timwhiting/Zotero/storage/F6V3KZHQ/Quiring et al. - 2021 - 3CPS The Design of an Environment-Focussed Interm.pdf:application/pdf},
}

@article{quiring_analyzing_2022,
	title = {Analyzing binding extent in {3CPS}},
	volume = {6},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Quiring, Benjamin and Reppy, John and Shivers, Olin},
	year = {2022},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {650--678},
	file = {Quiring et al. - 2022 - Analyzing binding extent in 3CPS.pdf:/Users/timwhiting/Zotero/storage/XR9BSLWB/Quiring et al. - 2022 - Analyzing binding extent in 3CPS.pdf:application/pdf},
}

@inproceedings{cousot_systematic_1979,
	title = {Systematic design of program analysis frameworks},
	booktitle = {Proceedings of the 6th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages},
	author = {Cousot, Patrick and Cousot, Radhia},
	year = {1979},
	keywords = {to-read},
	pages = {269--282},
	file = {Cousot and Cousot - 1979 - Systematic design of program analysis frameworks.pdf:/Users/timwhiting/Zotero/storage/G6ZW2XTM/Cousot and Cousot - 1979 - Systematic design of program analysis frameworks.pdf:application/pdf},
}

@inproceedings{brahmakshatriya_d2x_2023,
	title = {{D2X}: {An} {eXtensible} {conteXtual} {Debugger} for {Modern} {DSLs}},
	booktitle = {Proceedings of the 21st {ACM}/{IEEE} {International} {Symposium} on {Code} {Generation} and {Optimization}},
	author = {Brahmakshatriya, Ajay and Amarasinghe, Saman},
	year = {2023},
	keywords = {to-read},
	pages = {162--172},
	file = {Brahmakshatriya and Amarasinghe - 2023 - D2X An eXtensible conteXtual Debugger for Modern .pdf:/Users/timwhiting/Zotero/storage/SXXQYH4B/Brahmakshatriya and Amarasinghe - 2023 - D2X An eXtensible conteXtual Debugger for Modern .pdf:application/pdf},
}

@inproceedings{brahmakshatriya_buildit_2021,
	title = {{BuildIt}: {A} type-based multi-stage programming framework for code generation in {C}++},
	booktitle = {2021 {IEEE}/{ACM} {International} {Symposium} on {Code} {Generation} and {Optimization} ({CGO})},
	publisher = {IEEE},
	author = {Brahmakshatriya, Ajay and Amarasinghe, Saman},
	year = {2021},
	keywords = {to-read},
	pages = {39--51},
	file = {Brahmakshatriya and Amarasinghe - 2021 - BuildIt A type-based multi-stage programming fram.pdf:/Users/timwhiting/Zotero/storage/XXLP8UF3/Brahmakshatriya and Amarasinghe - 2021 - BuildIt A type-based multi-stage programming fram.pdf:application/pdf},
}

@inproceedings{bose_o_2010,
	title = {An {O} (log log n)-competitive binary search tree with optimal worst-case access times},
	booktitle = {Algorithm {Theory}-{SWAT} 2010: 12th {Scandinavian} {Symposium} and {Workshops} on {Algorithm} {Theory}, {Bergen}, {Norway}, {June} 21-23, 2010. {Proceedings} 12},
	publisher = {Springer},
	author = {Bose, Prosenjit and Douïeb, Karim and Dujmović, Vida and Fagerberg, Rolf},
	year = {2010},
	keywords = {to-read},
	pages = {38--49},
	file = {Bose et al. - 2010 - An O (log log n)-competitive binary search tree wi.pdf:/Users/timwhiting/Zotero/storage/HMGWAWZ4/Bose et al. - 2010 - An O (log log n)-competitive binary search tree wi.pdf:application/pdf},
}

@article{okasaki_red-black_1999,
	title = {Red-black trees in a functional setting},
	volume = {9},
	number = {4},
	journal = {Journal of functional programming},
	author = {Okasaki, Chris},
	year = {1999},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {471--477},
	file = {Okasaki - 1999 - Red-black trees in a functional setting.pdf:/Users/timwhiting/Zotero/storage/G9EV9P5W/Okasaki - 1999 - Red-black trees in a functional setting.pdf:application/pdf},
}

@article{morrisett_system_1999,
	title = {From {System} {F} to typed assembly language},
	volume = {21},
	number = {3},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Morrisett, Greg and Walker, David and Crary, Karl and Glew, Neal},
	year = {1999},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {certified code, closure conversion, secure extensible systems, type-directed compilation, typed assembly language, typed intermediate languages, to-read},
	pages = {527--568},
	file = {Morrisett et al. - 1999 - From System F to typed assembly language.pdf:/Users/timwhiting/Zotero/storage/NHW2MG5Z/Morrisett et al. - 1999 - From System F to typed assembly language.pdf:application/pdf},
}

@article{glaze_optimizing_2013,
	title = {Optimizing abstract abstract machines},
	volume = {48},
	number = {9},
	journal = {ACM SIGPLAN Notices},
	author = {Glaze, Dionna and Labich, Nicholas and Might, Matthew and Van Horn, David},
	year = {2013},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {443--454},
	file = {Glaze et al. - 2013 - Optimizing abstract abstract machines.pdf:/Users/timwhiting/Zotero/storage/3BA5WDMG/Glaze et al. - 2013 - Optimizing abstract abstract machines.pdf:application/pdf},
}

@inproceedings{jagannathan_unified_1995,
	title = {A unified treatment of flow analysis in higher-order languages},
	booktitle = {Proceedings of the 22nd {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Jagannathan, Suresh and Weeks, Stephen},
	year = {1995},
	keywords = {to-read},
	pages = {393--407},
	file = {Jagannathan and Weeks - 1995 - A unified treatment of flow analysis in higher-ord.pdf:/Users/timwhiting/Zotero/storage/TUEHSN76/Jagannathan and Weeks - 1995 - A unified treatment of flow analysis in higher-ord.pdf:application/pdf},
}

@inproceedings{gilray_pushdown_2016,
	title = {Pushdown control-flow analysis for free},
	booktitle = {Proceedings of the 43rd {Annual} {ACM} {SIGPLAN}-{SIGACT} {Symposium} on {Principles} of {Programming} {Languages}},
	author = {Gilray, Thomas and Lyde, Steven and Adams, Michael D and Might, Matthew and Van Horn, David},
	year = {2016},
	keywords = {to-read},
	pages = {691--704},
	file = {Gilray et al. - 2016 - Pushdown control-flow analysis for free.pdf:/Users/timwhiting/Zotero/storage/NYHVHYI6/Gilray et al. - 2016 - Pushdown control-flow analysis for free.pdf:application/pdf},
}

@inproceedings{vardoulakis_ordering_2011,
	title = {Ordering multiple continuations on the stack},
	booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} workshop on {Partial} evaluation and program manipulation},
	author = {Vardoulakis, Dimitrios and Shivers, Olin},
	year = {2011},
	keywords = {to-read},
	pages = {13--22},
	file = {Vardoulakis and Shivers - 2011 - Ordering multiple continuations on the stack.pdf:/Users/timwhiting/Zotero/storage/RPWRPXUC/Vardoulakis and Shivers - 2011 - Ordering multiple continuations on the stack.pdf:application/pdf},
}

@article{might_environment_2006,
	title = {Environment analysis via Δ{CFA}},
	volume = {41},
	number = {1},
	journal = {ACM SIGPLAN Notices},
	author = {Might, Matthew and Shivers, Olin},
	year = {2006},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {127--140},
	file = {Might and Shivers - 2006 - Environment analysis via ΔCFA.pdf:/Users/timwhiting/Zotero/storage/FXJ5WEQF/Might and Shivers - 2006 - Environment analysis via ΔCFA.pdf:application/pdf},
}

@inproceedings{flanagan_essence_1993,
	title = {The essence of compiling with continuations},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1993 conference on {Programming} language design and implementation},
	author = {Flanagan, Cormac and Sabry, Amr and Duba, Bruce F and Felleisen, Matthias},
	year = {1993},
	keywords = {to-read},
	pages = {237--247},
	file = {Flanagan et al. - 1993 - The essence of compiling with continuations.pdf:/Users/timwhiting/Zotero/storage/N8DCMX64/Flanagan et al. - 1993 - The essence of compiling with continuations.pdf:application/pdf},
}

@article{jones_secrets_2002,
	title = {Secrets of the glasgow haskell compiler inliner},
	volume = {12},
	number = {4-5},
	journal = {Journal of Functional Programming},
	author = {Jones, Simon Peyton and Marlow, Simon},
	year = {2002},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {393--434},
	file = {Jones and Marlow - 2002 - Secrets of the glasgow haskell compiler inliner.pdf:/Users/timwhiting/Zotero/storage/EHVUGCEI/Jones and Marlow - 2002 - Secrets of the glasgow haskell compiler inliner.pdf:application/pdf},
}

@article{zimmerman_langcc_2022,
	title = {langcc: {A} {Next}-{Generation} {Compiler} {Compiler}},
	journal = {arXiv preprint arXiv:2209.08385},
	author = {Zimmerman, Joe},
	year = {2022},
	keywords = {to-read},
	file = {Zimmerman - 2022 - langcc A Next-Generation Compiler Compiler.pdf:/Users/timwhiting/Zotero/storage/AA2HQXVL/Zimmerman - 2022 - langcc A Next-Generation Compiler Compiler.pdf:application/pdf},
}

@article{zimmerman_practical_2022,
	title = {Practical {LR} {Parser} {Generation}},
	journal = {arXiv preprint arXiv:2209.08383},
	author = {Zimmerman, Joe},
	year = {2022},
	keywords = {to-read},
	file = {Zimmerman - 2022 - Practical LR Parser Generation.pdf:/Users/timwhiting/Zotero/storage/SAH7VNXZ/Zimmerman - 2022 - Practical LR Parser Generation.pdf:application/pdf},
}

@article{wright_polymorphic_1998,
	title = {Polymorphic splitting: {An} effective polyvariant flow analysis},
	volume = {20},
	number = {1},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Wright, Andrew K and Jagannathan, Suresh},
	year = {1998},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {166--207},
	file = {Wright and Jagannathan - 1998 - Polymorphic splitting An effective polyvariant fl.pdf:/Users/timwhiting/Zotero/storage/BS8VEBMF/Wright and Jagannathan - 1998 - Polymorphic splitting An effective polyvariant fl.pdf:application/pdf},
}

@article{bruni_abstract_2019,
	title = {Abstract extensionality: on the properties of incomplete abstract interpretations},
	volume = {4},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Bruni, Roberto and Giacobazzi, Roberto and Gori, Roberta and Garcia-Contreras, Isabel and Pavlovic, Dusko},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--28},
	file = {Bruni et al. - 2019 - Abstract extensionality on the properties of inco.pdf:/Users/timwhiting/Zotero/storage/5KB6BEXS/Bruni et al. - 2019 - Abstract extensionality on the properties of inco.pdf:application/pdf},
}

@article{yallop_flap_2023,
	title = {flap: {A} {Deterministic} {Parser} with {Fused} {Lexing}},
	volume = {7},
	number = {PLDI},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Yallop, Jeremy and Xie, Ningning and Krishnaswami, Neel},
	year = {2023},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1194--1217},
	file = {Yallop et al. - 2023 - flap A Deterministic Parser with Fused Lexing.pdf:/Users/timwhiting/Zotero/storage/YBY5RAGX/Yallop et al. - 2023 - flap A Deterministic Parser with Fused Lexing.pdf:application/pdf},
}

@inproceedings{liang_hash-flow_2012,
	title = {Hash-flow taint analysis of higher-order programs},
	booktitle = {Proceedings of the 7th {Workshop} on {Programming} {Languages} and {Analysis} for {Security}},
	author = {Liang, Shuying and Might, Matthew},
	year = {2012},
	keywords = {to-read},
	pages = {1--12},
	file = {Liang and Might - 2012 - Hash-flow taint analysis of higher-order programs.pdf:/Users/timwhiting/Zotero/storage/DRRD3EM9/Liang and Might - 2012 - Hash-flow taint analysis of higher-order programs.pdf:application/pdf},
}

@article{zhang_better_2023,
	title = {Better {Together}: {Unifying} {Datalog} and {Equality} {Saturation}},
	volume = {7},
	url = {https://doi.org/10.1145/3591239},
	doi = {10.1145/3591239},
	abstract = {We present egglog, a fixpoint reasoning system that unifies Datalog and equality saturation (EqSat). Like Datalog, egglog supports efficient incremental execution, cooperating analyses, and lattice-based reasoning. Like EqSat, egglog supports term rewriting, efficient congruence closure, and extraction of optimized terms. We identify two recent applications – a unification-based pointer analysis in Datalog and an EqSat-based floating-point term rewriter – that have been hampered by features missing from Datalog but found in EqSat or vice-versa. We evaluate our system by reimplementing those projects in egglog. The resulting systems in egglog are faster, simpler, and fix bugs found in the original systems.},
	number = {PLDI},
	journal = {Proc. ACM Program. Lang.},
	author = {Zhang, Yihong and Wang, Yisu Remy and Flatt, Oliver and Cao, David and Zucker, Philip and Rosenthal, Eli and Tatlock, Zachary and Willsey, Max},
	month = jun,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Datalog, Equality saturation, Program optimization, Rewrite systems, to-read},
	file = {Zhang et al. - 2023 - Better Together Unifying Datalog and Equality Sat.pdf:/Users/timwhiting/Zotero/storage/VNNMQAZS/Zhang et al. - 2023 - Better Together Unifying Datalog and Equality Sat.pdf:application/pdf},
}

@inproceedings{might_logic-flow_2007,
	title = {Logic-flow analysis of higher-order programs},
	booktitle = {Proceedings of the 34th annual {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Might, Matthew},
	year = {2007},
	keywords = {to-read},
	pages = {185--198},
	file = {Might - 2007 - Logic-flow analysis of higher-order programs.pdf:/Users/timwhiting/Zotero/storage/WZMJSV9J/Might - 2007 - Logic-flow analysis of higher-order programs.pdf:application/pdf},
}

@inproceedings{liang_entangled_2013,
	title = {Entangled abstract domains for higher-order programs},
	booktitle = {Proceedings of the 2013 {Workshop} on {Scheme} and {Functional} {Programming}, {Washington}, {DC}},
	author = {Liang, Shuying and Might, Matthew},
	year = {2013},
	keywords = {to-read},
	file = {Liang and Might - 2013 - Entangled abstract domains for higher-order progra.pdf:/Users/timwhiting/Zotero/storage/B4ALCRY3/Liang and Might - 2013 - Entangled abstract domains for higher-order progra.pdf:application/pdf},
}

@article{moseley_derivative_2023,
	title = {Derivative {Based} {Nonbacktracking} {Real}-{World} {Regex} {Matching} with {Backtracking} {Semantics}},
	volume = {7},
	url = {https://doi.org/10.1145/3591262},
	doi = {10.1145/3591262},
	abstract = {We develop a new derivative based theory and algorithm for nonbacktracking regex matching that supports anchors and counting, preserves backtracking semantics, and can be extended with lookarounds. The algorithm has been implemented as a new regex backend in .NET and was extensively tested as part of the formal release process of .NET7. We present a formal proof of the correctness of the algorithm, which we believe to be the first of its kind concerning industrial implementations of regex matchers. The paper describes the complete foundation, the matching algorithm, and key aspects of the implementation involving a regex rewrite system, as well as a comprehensive evaluation over industrial case studies and other regex engines.},
	number = {PLDI},
	journal = {Proc. ACM Program. Lang.},
	author = {Moseley, Dan and Nishio, Mario and Perez Rodriguez, Jose and Saarikivi, Olli and Toub, Stephen and Veanes, Margus and Wan, Tiki and Xu, Eric},
	month = jun,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {automata, derivative, matching, PCRE, regex, symbolic, to-read},
	file = {Moseley et al. - 2023 - Derivative Based Nonbacktracking Real-World Regex .pdf:/Users/timwhiting/Zotero/storage/KNY4MZ7Z/Moseley et al. - 2023 - Derivative Based Nonbacktracking Real-World Regex .pdf:application/pdf},
}

@article{ma_context_2023,
	title = {Context {Sensitivity} without {Contexts}: {A} {Cut}-{Shortcut} {Approach} to {Fast} and {Precise} {Pointer} {Analysis}},
	volume = {7},
	url = {https://doi.org/10.1145/3591242},
	doi = {10.1145/3591242},
	abstract = {Over the past decades, context sensitivity has been considered as one of the most effective ideas for improving the precision of pointer analysis for Java. Different from the extremely fast context-insensitivity approach, context sensitivity requires every program method to be analyzed under different contexts for separating the static abstractions of different dynamic instantiations of the method’s variables and heap objects, and thus reducing spurious object flows introduced by method calls. However, despite great precision benefits, as each method is equivalently cloned and analyzed under each context, context sensitivity brings heavy efficiency costs. Recently, numerous selective context-sensitive approaches have been put forth for scaling pointer analysis to large and complex Java programs by applying contexts only to the selected methods while analyzing the remaining ones context-insensitively; however, because the selective approaches do not fundamentally alter the primary methodology of context sensitivity (and do not thus remove its efficiency bottleneck), they produce much improved but still limited results. In this work, we present a fundamentally different approach called Cut-Shortcut for fast and precise pointer analysis for Java. Its insight is simple: the main effect of cloning methods under different contexts is to filter spurious object flows that have been merged inside a callee method; from the view of a typical pointer flow graph (PFG), such effect can be simulated by cutting off (Cut) the edges that introduce precision loss to certain pointers and adding Shortcut edges directly from source pointers to the target ones circumventing the method on PFG. As a result, we can achieve the effect of context sensitivity without contexts. We identify three general program patterns and develop algorithms based on them to safely cut off and add shortcut edges on PFG, formalize them and formally prove the soundness. To comprehensively validate Cut-Shortcut’s effectiveness, we implement two versions of Cut-Shortcut for two state-of-the-art pointer analysis frameworks for Java, one in Datalog for the declarative Doop and the other in Java for the imperative Tai-e, and we consider all the large and complex programs used in recent literatures that meet the experimental requirements. The evaluation results are extremely promising: Cut-Shortcut is even able to run faster than context insensitivity for most evaluated programs while obtaining high precision that is comparable to context sensitivity (if scalable) in both frameworks. This is for the first time that we have been able to achieve such a good efficiency and precision trade-off for those hard-to-analyze programs, and we hope Cut-Shortcut could offer new perspectives for developing more effective pointer analysis for Java in the future.},
	number = {PLDI},
	journal = {Proc. ACM Program. Lang.},
	author = {Ma, Wenjie and Yang, Shengyuan and Tan, Tian and Ma, Xiaoxing and Xu, Chang and Li, Yue},
	month = jun,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Alias Analysis, Context Sensitivity, Java, Pointer Analysis, to-read},
	file = {Ma et al. - 2023 - Context Sensitivity without Contexts A Cut-Shortc.pdf:/Users/timwhiting/Zotero/storage/5QATY4T8/Ma et al. - 2023 - Context Sensitivity without Contexts A Cut-Shortc.pdf:application/pdf},
}

@article{brandon_better_2023,
	title = {Better {Defunctionalization} through {Lambda} {Set} {Specialization}},
	volume = {7},
	url = {https://doi.org/10.1145/3591260},
	doi = {10.1145/3591260},
	abstract = {Higher-order functions pose a challenge for both static program analyses and optimizing compilers. To simplify the analysis and compilation of languages with higher-order functions, a rich body of prior work has proposed a variety of defunctionalization techniques, which can eliminate higher-order functions from a program by transforming the program to a semantically-equivalent first-order representation. Several modern languages take this a step further, specializing higher-order functions with respect to the functions on which they operate, and in turn allowing compilers to generate more efficient code. However, existing specializing defunctionalization techniques restrict how function values may be used, forcing implementations to fall back on costly dynamic alternatives. We propose lambda set specialization (LSS), the first specializing defunctionalization technique which imposes no restrictions on how function values may be used. We formulate LSS in terms of a polymorphic type system which tracks the flow of function values through the program, and use this type system to recast specialization of higher-order functions with respect to their arguments as a form of type monomorphization. We show that our type system admits a simple and tractable type inference algorithm, and give a formalization and fully-mechanized proof in the Isabelle/HOL proof assistant showing soundness and completeness of the type inference algorithm with respect to the type system. To show the benefits of LSS, we evaluate its impact on the run time performance of code generated by the MLton compiler for Standard ML, the OCaml compiler, and the new Morphic functional programming language. We find that pre-processing with LSS achieves run time speedups of up to 6.85x under MLton, 3.45x for OCaml, and 78.93x for Morphic.},
	number = {PLDI},
	journal = {Proc. ACM Program. Lang.},
	author = {Brandon, William and Driscoll, Benjamin and Dai, Frank and Berkow, Wilson and Milano, Mae},
	month = jun,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {defunctionalization, monomorphization, type systems, to-read},
	file = {Brandon et al. - 2023 - Better Defunctionalization through Lambda Set Spec.pdf:/Users/timwhiting/Zotero/storage/586Z4LMZ/Brandon et al. - 2023 - Better Defunctionalization through Lambda Set Spec.pdf:application/pdf},
}

@inproceedings{kameyama_shifting_2009,
	title = {Shifting the stage: {Staging} with delimited control},
	booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN} workshop on {Partial} {Evaluation} and {Program} {Manipulation}},
	author = {Kameyama, Yukiyoshi and Kiselyov, Oleg and Shan, Chung-chieh},
	year = {2009},
	keywords = {to-read},
	pages = {111--120},
	file = {Kameyama et al. - 2009 - Shifting the stage Staging with delimited control.pdf:/Users/timwhiting/Zotero/storage/GCV94SS6/Kameyama et al. - 2009 - Shifting the stage Staging with delimited control.pdf:application/pdf},
}

@inproceedings{danvy_operational_1999,
	title = {An operational investigation of the {CPS} hierarchy},
	booktitle = {European {Symposium} {On} {Programming}},
	publisher = {Springer},
	author = {Danvy, Olivier and Yang, Zhe},
	year = {1999},
	keywords = {to-read},
	pages = {224--242},
	file = {Danvy and Yang - 1999 - An operational investigation of the CPS hierarchy.pdf:/Users/timwhiting/Zotero/storage/8GPJL3N7/Danvy and Yang - 1999 - An operational investigation of the CPS hierarchy.pdf:application/pdf},
}

@inproceedings{danvy_abstracting_1990,
	title = {Abstracting control},
	booktitle = {Proceedings of the 1990 {ACM} {Conference} on {LISP} and {Functional} {Programming}},
	author = {Danvy, Olivier and Filinski, Andrzej},
	year = {1990},
	keywords = {to-read},
	pages = {151--160},
	file = {Danvy and Filinski - 1990 - Abstracting control.pdf:/Users/timwhiting/Zotero/storage/SFSAVBSB/Danvy and Filinski - 1990 - Abstracting control.pdf:application/pdf},
}

@inproceedings{maurer_compiling_2017,
	title = {Compiling without continuations},
	booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	author = {Maurer, Luke and Downen, Paul and Ariola, Zena M and Peyton Jones, Simon},
	year = {2017},
	keywords = {to-read},
	pages = {482--494},
	file = {Maurer et al. - 2017 - Compiling without continuations.pdf:/Users/timwhiting/Zotero/storage/HW7YLWIZ/Maurer et al. - 2017 - Compiling without continuations.pdf:application/pdf},
}

@inproceedings{odersky_second_1995,
	title = {A second look at overloading},
	booktitle = {Proceedings of the seventh international conference on {Functional} programming languages and computer architecture},
	author = {Odersky, Martin and Wadler, Philip and Wehr, Martin},
	year = {1995},
	keywords = {to-read},
	pages = {135--146},
	file = {Odersky et al. - 1995 - A second look at overloading.pdf:/Users/timwhiting/Zotero/storage/C8QX3U3R/Odersky et al. - 1995 - A second look at overloading.pdf:application/pdf},
}

@inproceedings{lyde_strong_2014,
	title = {Strong function call},
	volume = {2014},
	booktitle = {Workshop on {Higher}-{Order} {Program} {Analysis}},
	author = {Lyde, Steven and Might, Matthew},
	year = {2014},
	keywords = {to-read},
	file = {Lyde and Might - 2014 - Strong function call.pdf:/Users/timwhiting/Zotero/storage/FFSXF5ZB/Lyde and Might - 2014 - Strong function call.pdf:application/pdf},
}

@inproceedings{lyde_environment_2014,
	title = {Environment unrolling},
	volume = {2014},
	booktitle = {Workshop on {Higher}-{Order} {Program} {Analysis}},
	publisher = {Citeseer},
	author = {Lyde, Steven and Might, Matthew},
	year = {2014},
	keywords = {to-read},
	file = {Lyde and Might - 2014 - Environment unrolling.pdf:/Users/timwhiting/Zotero/storage/QJG2K3FF/Lyde and Might - 2014 - Environment unrolling.pdf:application/pdf},
}

@inproceedings{liang_fast_2014,
	title = {Fast flow analysis with godel hashes},
	booktitle = {2014 {IEEE} 14th {International} {Working} {Conference} on {Source} {Code} {Analysis} and {Manipulation}},
	publisher = {IEEE},
	author = {Liang, Shuying and Sun, Weibin and Might, Matthew},
	year = {2014},
	keywords = {to-read},
	pages = {225--234},
	file = {Liang et al. - 2014 - Fast flow analysis with godel hashes.pdf:/Users/timwhiting/Zotero/storage/9UAP3JJF/Liang et al. - 2014 - Fast flow analysis with godel hashes.pdf:application/pdf},
}

@inproceedings{liang_pruning_2014,
	title = {Pruning, pushdown exception-flow analysis},
	booktitle = {2014 {IEEE} 14th {International} {Working} {Conference} on {Source} {Code} {Analysis} and {Manipulation}},
	publisher = {IEEE},
	author = {Liang, Shuying and Sun, Weibin and Might, Matthew and Keep, Andrew and Van Horn, David},
	year = {2014},
	keywords = {to-read},
	pages = {265--274},
	file = {Liang et al. - 2014 - Pruning, pushdown exception-flow analysis.pdf:/Users/timwhiting/Zotero/storage/7UXXEH4Q/Liang et al. - 2014 - Pruning, pushdown exception-flow analysis.pdf:application/pdf},
}

@inproceedings{jenkins_concrete_2015,
	title = {Concrete and abstract interpretation: {Better} together},
	volume = {14},
	booktitle = {Proceedings of the 2014 {Scheme} and {Functional} {Programming} {Workshop}, {SFP}},
	publisher = {Citeseer},
	author = {Jenkins, Maria and Andersen, Leif and Gilray, Thomas and Might, Matthew},
	year = {2015},
	keywords = {to-read},
	file = {Jenkins et al. - 2015 - Concrete and abstract interpretation Better toget.pdf:/Users/timwhiting/Zotero/storage/X4Y83DW7/Jenkins et al. - 2015 - Concrete and abstract interpretation Better toget.pdf:application/pdf},
}

@inproceedings{blume_demand-driven_1995,
	title = {Demand-driven, symbolic range propagation},
	booktitle = {International {Workshop} on {Languages} and {Compilers} for {Parallel} {Computing}},
	publisher = {Springer},
	author = {Blume, William and Eigenmann, Rudolf},
	year = {1995},
	keywords = {to-read},
	pages = {141--160},
	file = {Blume and Eigenmann - 1995 - Demand-driven, symbolic range propagation.pdf:/Users/timwhiting/Zotero/storage/Z2AE3CMZ/Blume and Eigenmann - 1995 - Demand-driven, symbolic range propagation.pdf:application/pdf},
}

@inproceedings{bodik_abcd_2000,
	address = {New York, NY, USA},
	series = {{PLDI} '00},
	title = {{ABCD}: {Eliminating} {Array} {Bounds} {Checks} on {Demand}},
	isbn = {1-58113-199-2},
	url = {https://doi.org/10.1145/349299.349342},
	doi = {10.1145/349299.349342},
	abstract = {To guarantee typesafe execution, Java and other strongly typed languages require bounds checking of array accesses. Because array-bounds checks may raise exceptions, they block code motion of instructions with side effects, thus preventing many useful code optimizations, such as partial redundancy elimination or instruction scheduling of memory operations. Furthermore, because it is not expressible at bytecode level, the elimination of bounds checks can only be performed at run time, after the bytecode program is loaded. Using existing powerful bounds-check optimizers at run time is not feasible, however, because they are too heavyweight for the dynamic compilation setting.ABCD is a light-weight algorithm for elimination of Array Bounds Checks on Demand. Its design emphasizes simplicity and efficiency. In essence, ABCD works by adding a few edges to the SSA value graph and performing a simple traversal of the graph. Despite its simplicity, ABCD is surprisingly powerful. On our benchmarks, ABCD removes on average 45\% of dynamic bound check instructions, sometimes achieving near-ideal optimization. The efficiency of ABCD stems from two factors. First, ABCD works on a sparse representation. As a result, it requires on average fewer than 10 simple analysis steps per bounds check. Second, ABCD is demand-driven. It can be applied to a set of frequently executed (hot) bounds checks, which makes it suitable for the dynamic-compilation setting, in which compile-time cost is constrained but hot statements are known.},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2000 {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {Association for Computing Machinery},
	author = {Bodík, Rastislav and Gupta, Rajiv and Sarkar, Vivek},
	year = {2000},
	note = {event-place: Vancouver, British Columbia, Canada},
	keywords = {to-read},
	pages = {321--333},
	file = {Bodík et al. - 2000 - ABCD Eliminating Array Bounds Checks on Demand.pdf:/Users/timwhiting/Zotero/storage/8EBGUGAJ/Bodík et al. - 2000 - ABCD Eliminating Array Bounds Checks on Demand.pdf:application/pdf},
}

@techreport{lorenzen_fp2_2023,
	title = {{FP}{\textasciicircum}2: {Fully} in-{Place} {Functional} {Programming}},
	url = {https://www.microsoft.com/en-us/research/publication/fp2-fully-in-place-functional-programming/},
	abstract = {As functional programmers we always face a dilemma: should we write purely functional code, or sacrifice purity for efficiency and resort to in-place updates? This paper identifies precisely when we can have the best of both worlds: a wide class of purely functional programs can be executed safely using in-place updates without requiring allocation. We describe a linear \_fully in-place\_ (FIP) calculus where we prove that we can always execute such functions in way that requires no (de)allocation and uses constant stack space. Of course, such calculus is only relevant if we can express interesting algorithms, and we show many examples, including splay trees, finger trees, merge sort, and quick sort. We also show how we can generically derive a map function over \_any\_ polynomial data type that is fully in-place and uses neither heap- nor stack space. We consider two approaches to embed the FIP calculus in a larger language, either a static approach based on uniqueness typing, or a dynamic approach based on precise reference counting. We have a full implementation based on the dynamic approach in the Koka language and all examples in the paper can be checked and executed fully in-place.},
	number = {MSR-TR-2023-19},
	institution = {Microsoft},
	author = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter},
	month = may,
	year = {2023},
	keywords = {to-read},
	file = {Lorenzen et al. - 2023 - FP^2 Fully in-Place Functional Programming.pdf:/Users/timwhiting/Zotero/storage/J3ZWNIJQ/Lorenzen et al. - 2023 - FP^2 Fully in-Place Functional Programming.pdf:application/pdf},
}

@article{adams_orbit_1986,
	title = {Orbit: {An} optimizing compiler for {Scheme}},
	volume = {21},
	number = {7},
	journal = {ACM SIGPLAN Notices},
	author = {Adams, Norman and Kranz, David and Kelsey, Richard and Rees, Jonathan and Hudak, Paul and Philbin, James},
	year = {1986},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {219--233},
	file = {Adams et al. - 1986 - Orbit An optimizing compiler for Scheme.pdf:/Users/timwhiting/Zotero/storage/EAY39CPD/Adams et al. - 1986 - Orbit An optimizing compiler for Scheme.pdf:application/pdf},
}

@article{jeon_precise_2018,
	title = {Precise and {Scalable} {Points}-to {Analysis} via {Data}-{Driven} {Context} {Tunneling}},
	volume = {2},
	url = {https://doi.org/10.1145/3276510},
	doi = {10.1145/3276510},
	abstract = {We present context tunneling, a new approach for making k-limited context-sensitive points-to analysis precise and scalable. As context-sensitivity holds the key to the development of precise and scalable points-to analysis, a variety of techniques for context-sensitivity have been proposed. However, existing approaches such as k-call-site-sensitivity or k-object-sensitivity have a significant weakness that they unconditionally update the context of a method at every call-site, allowing important context elements to be overwritten by more recent, but not necessarily more important, context elements. In this paper, we show that this is a key limiting factor of existing context-sensitive analyses, and demonstrate that remarkable increase in both precision and scalability can be gained by maintaining important context elements only. Our approach, called context tunneling, updates contexts selectively and decides when to propagate the same context without modification. We attain context tunneling via a data-driven approach. The effectiveness of context tunneling is very sensitive to the choice of important context elements. Even worse, precision is not monotonically increasing with respect to the ordering of the choices. As a result, manually coming up with a good heuristic rule for context tunneling is extremely challenging and likely fails to maximize its potential. We address this challenge by developing a specialized data-driven algorithm, which is able to automatically search for high-quality heuristics over the non-monotonic space of context tunneling. We implemented our approach in the Doop framework and applied it to four major flavors of context-sensitivity: call-site-sensitivity, object-sensitivity, type-sensitivity, and hybrid context-sensitivity. In all cases, 1-context-sensitive analysis with context tunneling far outperformed deeper context-sensitivity with k=2 in both precision and scalability.},
	number = {OOPSLA},
	journal = {Proc. ACM Program. Lang.},
	author = {Jeon, Minseok and Jeong, Sehun and Oh, Hakjoo},
	month = oct,
	year = {2018},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Context-sensitive analysis, Data-driven program analysis, Points-to analysis, to-read},
	file = {Jeon et al. - 2018 - Precise and Scalable Points-to Analysis via Data-D.pdf:/Users/timwhiting/Zotero/storage/VLIQS3YS/Jeon et al. - 2018 - Precise and Scalable Points-to Analysis via Data-D.pdf:application/pdf},
}

@book{dolan_algebraic_2017,
	title = {Algebraic subtyping},
	publisher = {BCS, The Chartered Institute for IT},
	author = {Dolan, Stephen},
	year = {2017},
	keywords = {to-read},
}

@inproceedings{reps_precise_1995,
	title = {Precise interprocedural dataflow analysis via graph reachability},
	booktitle = {Proceedings of the 22nd {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Reps, Thomas and Horwitz, Susan and Sagiv, Mooly},
	year = {1995},
	keywords = {to-read},
	pages = {49--61},
	file = {Reps et al. - 1995 - Precise interprocedural dataflow analysis via grap.pdf:/Users/timwhiting/Zotero/storage/T6AYFSA5/Reps et al. - 1995 - Precise interprocedural dataflow analysis via grap.pdf:application/pdf},
}

@inproceedings{cousot_static_1976,
	title = {Static determination of dynamic properties of programs},
	booktitle = {Proceedings of the 2nd {International} {Symposium} on {Programming}, {Paris}, {France}},
	publisher = {Dunod},
	author = {Cousot, Patrick and Cousot, Radhia},
	year = {1976},
	keywords = {to-read},
	pages = {106--130},
	file = {Cousot and Cousot - 1976 - Static determination of dynamic properties of prog.pdf:/Users/timwhiting/Zotero/storage/QMSQAN2V/Cousot and Cousot - 1976 - Static determination of dynamic properties of prog.pdf:application/pdf},
}

@article{vardoulakis_cfa2_2011,
	title = {{CFA2}: a {Context}-{Free} {Approach} to {Control}-{Flow} {Analysis}},
	volume = {Volume 7, Issue 2},
	url = {https://doi.org/10.2168%2Flmcs-7%282%3A3%292011},
	doi = {10.2168/lmcs-7(2:3)2011},
	journal = {Logical Methods in Computer Science},
	author = {Vardoulakis, Dimitrios and Shivers, Olin},
	month = may,
	year = {2011},
	note = {Publisher: Centre pour la Communication Scientifique Directe (CCSD)},
	keywords = {to-read},
	file = {Vardoulakis and Shivers - 2011 - CFA2 a Context-Free Approach to Control-Flow Anal.pdf:/Users/timwhiting/Zotero/storage/RCAWTA49/Vardoulakis and Shivers - 2011 - CFA2 a Context-Free Approach to Control-Flow Anal.pdf:application/pdf},
}

@article{sharir_structural_1980,
	title = {Structural analysis: {A} new approach to flow analysis in optimizing compilers},
	volume = {5},
	number = {3-4},
	journal = {Computer Languages},
	author = {Sharir, Micha},
	year = {1980},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {141--153},
	file = {Sharir - 1980 - Structural analysis A new approach to flow analys.pdf:/Users/timwhiting/Zotero/storage/CD24DDS8/Sharir - 1980 - Structural analysis A new approach to flow analys.pdf:application/pdf},
}

@book{sharir_two_1978,
	title = {Two approaches to interprocedural data flow analysis},
	publisher = {New York University. Courant Institute of Mathematical Sciences …},
	author = {Sharir, Micha and Pnueli, Amir and {others}},
	year = {1978},
	keywords = {to-read},
	file = {Sharir et al. - 1978 - Two approaches to interprocedural data flow analys.pdf:/Users/timwhiting/Zotero/storage/S4W2IDLP/Sharir et al. - 1978 - Two approaches to interprocedural data flow analys.pdf:application/pdf},
}

@inproceedings{cousot_automatic_1978,
	title = {Automatic discovery of linear restraints among variables of a program},
	booktitle = {Proceedings of the 5th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages},
	author = {Cousot, Patrick and Halbwachs, Nicolas},
	year = {1978},
	keywords = {to-read},
	pages = {84--96},
	file = {Cousot and Halbwachs - 1978 - Automatic discovery of linear restraints among var.pdf:/Users/timwhiting/Zotero/storage/XD87FRV2/Cousot and Halbwachs - 1978 - Automatic discovery of linear restraints among var.pdf:application/pdf},
}

@inproceedings{cousot_abstract_1977,
	address = {New York, NY, USA},
	series = {{POPL} '77},
	title = {Abstract {Interpretation}: {A} {Unified} {Lattice} {Model} for {Static} {Analysis} of {Programs} by {Construction} or {Approximation} of {Fixpoints}},
	isbn = {978-1-4503-7350-0},
	url = {https://doi.org/10.1145/512950.512973},
	doi = {10.1145/512950.512973},
	abstract = {A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the results of abstract execution give some information on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text -1515 * 17 may be understood to denote computations on the abstract universe (+), (-), (±) where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution -1515 * 17 → -(+) * (+) → (-) * (+) → (-), proves that -1515 * 17 is a negative number. Abstract interpretation is concerned by a particular underlying structure of the usual universe of computations (the sign, in our example). It gives a summary of some facets of the actual executions of a program. In general this summary is simple to obtain but inaccurate (e.g. -1515 + 17 → -(+) + (+) → (-) + (+) → (±)). Despite its fundamentally incomplete results abstract interpretation allows the programmer or the compiler to answer questions which do not need full knowledge of program executions or which tolerate an imprecise answer, (e.g. partial correctness proofs of programs ignoring the termination problems, type checking, program optimizations which are not carried in the absence of certainty about their feasibility, …).},
	booktitle = {Proceedings of the 4th {ACM} {SIGACT}-{SIGPLAN} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {Association for Computing Machinery},
	author = {Cousot, Patrick and Cousot, Radhia},
	year = {1977},
	note = {event-place: Los Angeles, California},
	keywords = {to-read},
	pages = {238--252},
	file = {Cousot and Cousot - 1977 - Abstract Interpretation A Unified Lattice Model f.pdf:/Users/timwhiting/Zotero/storage/P4G6EAZY/Cousot and Cousot - 1977 - Abstract Interpretation A Unified Lattice Model f.pdf:application/pdf},
}

@article{parreaux_simple_2020,
	title = {The simple essence of algebraic subtyping: principal type inference with subtyping made easy (functional pearl)},
	volume = {4},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Parreaux, Lionel},
	year = {2020},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--28},
	file = {Parreaux - 2020 - The simple essence of algebraic subtyping princip.pdf:/Users/timwhiting/Zotero/storage/9WISRFYE/Parreaux - 2020 - The simple essence of algebraic subtyping princip.pdf:application/pdf},
}

@inproceedings{montagu_trace-based_2021,
	address = {New York, NY, USA},
	series = {{PLDI} 2021},
	title = {Trace-{Based} {Control}-{Flow} {Analysis}},
	isbn = {978-1-4503-8391-2},
	url = {https://doi.org/10.1145/3453483.3454057},
	doi = {10.1145/3453483.3454057},
	abstract = {We define a small-step semantics for the untyped λ-calculus, that traces the β-reductions that occur during evaluation. By abstracting the computation traces, we reconstruct k-CFA using abstract interpretation, and justify constraint-based k-CFA in a semantic way. The abstract interpretation of the trace semantics also paves the way for introducing widening operators in CFA that go beyond existing analyses, that are all based on exploring a finite state space. We define ∇CFA, a widening-based analysis that limits the cycles in call stacks, and can achieve better precision than k-CFA at a similar cost.},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {Association for Computing Machinery},
	author = {Montagu, Benoît and Jensen, Thomas},
	year = {2021},
	note = {event-place: Virtual, Canada},
	keywords = {abstract interpretation, control flow analysis, lambda-calculus, program traces, widening, to-read},
	pages = {482--496},
	file = {Montagu and Jensen - 2021 - Trace-Based Control-Flow Analysis.pdf:/Users/timwhiting/Zotero/storage/QL5KZ7TH/Montagu and Jensen - 2021 - Trace-Based Control-Flow Analysis.pdf:application/pdf},
}

@misc{jaiswal_demand-driven_2018,
	title = {Demand-driven {Alias} {Analysis} : {Formalizing} {Bidirectional} {Analyses} for {Soundness} and {Precision}},
	author = {Jaiswal, Swati and Khedker, Uday P. and Chakraborty, Supratik},
	year = {2018},
	note = {\_eprint: 1802.00932},
	keywords = {to-read},
	file = {Jaiswal et al. - 2018 - Demand-driven Alias Analysis  Formalizing Bidirec.pdf:/Users/timwhiting/Zotero/storage/SRRTUYK9/Jaiswal et al. - 2018 - Demand-driven Alias Analysis  Formalizing Bidirec.pdf:application/pdf},
}

@inproceedings{arceri_speeding_2023,
	address = {New York, NY, USA},
	series = {{SOAP} 2023},
	title = {Speeding up {Static} {Analysis} with the {Split} {Operator}},
	isbn = {9798400701702},
	url = {https://doi.org/10.1145/3589250.3596141},
	doi = {10.1145/3589250.3596141},
	abstract = {In the context of static analysis based on Abstract Interpretation, we propose a new abstract operator modeling the split of control flow paths: the goal of the operator is to enable a more efficient analysis when using abstract domains that are computationally expensive, having no effect on precision. Focusing on the case of conditional branches guarded by numeric linear constraints, we provide a preliminary experimental evaluation showing that, by using the split operator, we can achieve significant efficiency improvements for a static analysis based on the domain of convex polyhedra. We also briefly discuss the applicability of this new operator to different, possibly non-numeric abstract domains.},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} {International} {Workshop} on the {State} {Of} the {Art} in {Program} {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Arceri, Vincenzo and Dolcetti, Greta and Zaffanella, Enea},
	year = {2023},
	note = {event-place: Orlando, FL, USA},
	keywords = {Abstract Interpretation, Abstract Operators, Static Analysis, to-read},
	pages = {14--19},
	file = {Arceri et al. - 2023 - Speeding up Static Analysis with the Split Operato.pdf:/Users/timwhiting/Zotero/storage/JH6P92RL/Arceri et al. - 2023 - Speeding up Static Analysis with the Split Operato.pdf:application/pdf},
}

@article{ramsey_beyond_2022,
	title = {Beyond {Relooper}: {Recursive} {Translation} of {Unstructured} {Control} {Flow} to {Structured} {Control} {Flow} ({Functional} {Pearl})},
	volume = {6},
	url = {https://doi.org/10.1145/3547621},
	doi = {10.1145/3547621},
	abstract = {In many compilers, control flow is represented using an arbitrary directed graph. But in some interesting target languages, including JavaScript and WebAssembly, intraprocedural control flow can be expressed only in structured ways, using loops, conditionals, and multilevel breaks or exits. As was shown by Peterson, Kasami, and Tokura in 1973, such structured control flow can be obtained by translating arbitrary control flow. The translation uses two standard analyses, but as published, it takes three passes—which may explain why it was overlooked by Emscripten, a popular compiler from C to JavaScript. By tweaking the analyses and by applying fundamental ideas from functional programming (recursive functions and immutable abstract-syntax trees), the translation, along with a couple of code improvements, can be implemented in a single pass. This new implementation is slated to be added to the Glasgow Haskell Compiler. Its single-pass translation, its immutable representation, and its use of dominator trees make it much easier to reason about than the original translation.},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Ramsey, Norman},
	month = aug,
	year = {2022},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {control-flow analysis, dominator tree, Haskell, reverse postorder numbering, WebAssembly, to-read},
	file = {Ramsey - 2022 - Beyond Relooper Recursive Translation of Unstruct.pdf:/Users/timwhiting/Zotero/storage/LUIUT5U8/Ramsey - 2022 - Beyond Relooper Recursive Translation of Unstruct.pdf:application/pdf},
}

@inproceedings{facchinetti_relative_2017,
	title = {Relative store fragments for singleton abstraction},
	booktitle = {Static {Analysis}: 24th {International} {Symposium}, {SAS} 2017, {New} {York}, {NY}, {USA}, {August} 30–{September} 1, 2017, {Proceedings} 24},
	publisher = {Springer},
	author = {Facchinetti, Leandro and Palmer, Zachary and Smith, Scott F},
	year = {2017},
	keywords = {to-read},
	pages = {106--127},
	file = {Facchinetti et al. - 2017 - Relative store fragments for singleton abstraction.pdf:/Users/timwhiting/Zotero/storage/HIZE5MSN/Facchinetti et al. - 2017 - Relative store fragments for singleton abstraction.pdf:application/pdf},
}

@article{illous_relational_2021,
	title = {A relational shape abstract domain},
	volume = {57},
	number = {3},
	journal = {Formal Methods in System Design},
	author = {Illous, Hugo and Lemerre, Matthieu and Rival, Xavier},
	year = {2021},
	note = {Publisher: Springer},
	keywords = {to-read},
	pages = {343--400},
	file = {Illous et al. - 2021 - A relational shape abstract domain.pdf:/Users/timwhiting/Zotero/storage/EUCNRPN9/Illous et al. - 2021 - A relational shape abstract domain.pdf:application/pdf},
}

@inproceedings{reynolds_separation_2002,
	title = {Separation logic: {A} logic for shared mutable data structures},
	booktitle = {Proceedings 17th {Annual} {IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	publisher = {IEEE},
	author = {Reynolds, John C},
	year = {2002},
	keywords = {to-read},
	pages = {55--74},
	file = {Reynolds - 2002 - Separation logic A logic for shared mutable data .pdf:/Users/timwhiting/Zotero/storage/DF82BPDB/Reynolds - 2002 - Separation logic A logic for shared mutable data .pdf:application/pdf},
}

@article{hoare_axiomatic_1969,
	title = {An axiomatic basis for computer programming},
	volume = {12},
	number = {10},
	journal = {Communications of the ACM},
	author = {Hoare, Charles Antony Richard},
	year = {1969},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {576--580},
	file = {Hoare - 1969 - An axiomatic basis for computer programming.pdf:/Users/timwhiting/Zotero/storage/LZ2ESL28/Hoare - 1969 - An axiomatic basis for computer programming.pdf:application/pdf},
}

@article{hoare_proof_1971,
	title = {Proof of a program: {FIND}},
	volume = {14},
	number = {1},
	journal = {Communications of the ACM},
	author = {Hoare, Charles AR},
	year = {1971},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {39--45},
	file = {Hoare - 1971 - Proof of a program FIND.pdf:/Users/timwhiting/Zotero/storage/IRNAB2IF/Hoare - 1971 - Proof of a program FIND.pdf:application/pdf},
}

@inproceedings{glaze_abstracting_2014,
	title = {Abstracting abstract control},
	booktitle = {Proceedings of the 10th {ACM} {Symposium} on {Dynamic} languages},
	author = {Glaze, Dionna and Van Horn, David},
	year = {2014},
	keywords = {to-read},
	pages = {11--22},
	file = {Glaze and Van Horn - 2014 - Abstracting abstract control.pdf:/Users/timwhiting/Zotero/storage/DHHPJFWN/Glaze and Van Horn - 2014 - Abstracting abstract control.pdf:application/pdf},
}

@article{harrison_compiler_1977,
	title = {Compiler analysis of the value ranges for variables},
	number = {3},
	journal = {IEEE Transactions on software engineering},
	author = {Harrison, William H.},
	year = {1977},
	note = {Publisher: IEEE},
	keywords = {to-read},
	pages = {243--250},
	file = {Harrison - 1977 - Compiler analysis of the value ranges for variable.pdf:/Users/timwhiting/Zotero/storage/MHIF7MLR/Harrison - 1977 - Compiler analysis of the value ranges for variable.pdf:application/pdf},
}

@inproceedings{shivers_modular_2011,
	title = {Modular rollback through control logging: a pair of twin functional pearls},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} international conference on {Functional} programming},
	author = {Shivers, Olin and Turon, Aaron J},
	year = {2011},
	keywords = {to-read},
	pages = {58--68},
	file = {Shivers and Turon - 2011 - Modular rollback through control logging a pair o.pdf:/Users/timwhiting/Zotero/storage/8TIC9TV5/Shivers and Turon - 2011 - Modular rollback through control logging a pair o.pdf:application/pdf},
}

@inproceedings{biswas_demand-driven_1997,
	title = {A demand-driven set-based analysis},
	booktitle = {Proceedings of the 24th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Biswas, Sandip K},
	year = {1997},
	keywords = {to-read},
	pages = {372--385},
	file = {Biswas - 1997 - A demand-driven set-based analysis.pdf:/Users/timwhiting/Zotero/storage/2PEF6TME/Biswas - 1997 - A demand-driven set-based analysis.pdf:application/pdf},
}

@inproceedings{midtgaard_calculational_2008,
	title = {A calculational approach to control-flow analysis by abstract interpretation},
	booktitle = {International {Static} {Analysis} {Symposium}},
	publisher = {Springer},
	author = {Midtgaard, Jan and Jensen, Thomas},
	year = {2008},
	keywords = {to-read},
	pages = {347--362},
	file = {Midtgaard and Jensen - 2008 - A calculational approach to control-flow analysis .pdf:/Users/timwhiting/Zotero/storage/VRMJIQ48/Midtgaard and Jensen - 2008 - A calculational approach to control-flow analysis .pdf:application/pdf},
}

@inproceedings{heintze_linear-time_1997,
	title = {Linear-time subtransitive control flow analysis},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1997 conference on {Programming} language design and implementation},
	author = {Heintze, Nevin and McAllester, David},
	year = {1997},
	keywords = {to-read},
	pages = {261--272},
	file = {Heintze and McAllester - 1997 - Linear-time subtransitive control flow analysis.pdf:/Users/timwhiting/Zotero/storage/Y3SBSFX2/Heintze and McAllester - 1997 - Linear-time subtransitive control flow analysis.pdf:application/pdf},
}

@inproceedings{nicolay_effect-driven_2019,
	title = {Effect-driven flow analysis},
	booktitle = {Verification, {Model} {Checking}, and {Abstract} {Interpretation}: 20th {International} {Conference}, {VMCAI} 2019, {Cascais}, {Portugal}, {January} 13–15, 2019, {Proceedings} 20},
	publisher = {Springer},
	author = {Nicolay, Jens and Stiévenart, Quentin and De Meuter, Wolfgang and De Roover, Coen},
	year = {2019},
	keywords = {to-read},
	pages = {247--274},
	file = {Nicolay et al. - 2019 - Effect-driven flow analysis.pdf:/Users/timwhiting/Zotero/storage/DQNDNKRI/Nicolay et al. - 2019 - Effect-driven flow analysis.pdf:application/pdf},
}

@inproceedings{stein_demanded_2021,
	title = {Demanded abstract interpretation},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	author = {Stein, Benno and Chang, Bor-Yuh Evan and Sridharan, Manu},
	year = {2021},
	keywords = {to-read},
	pages = {282--295},
	file = {Stein et al. - 2021 - Demanded abstract interpretation.pdf:/Users/timwhiting/Zotero/storage/NNNEYJWQ/Stein et al. - 2021 - Demanded abstract interpretation.pdf:application/pdf},
}

@inproceedings{bergstrom_practical_2014,
	address = {New York, NY, USA},
	series = {{ICFP} '14},
	title = {Practical and {Effective} {Higher}-{Order} {Optimizations}},
	isbn = {978-1-4503-2873-9},
	url = {https://doi.org/10.1145/2628136.2628153},
	doi = {10.1145/2628136.2628153},
	abstract = {Inlining is an optimization that replaces a call to a function with that function's body. This optimization not only reduces the overhead of a function call, but can expose additional optimization opportunities to the compiler, such as removing redundant operations or unused conditional branches. Another optimization, copy propagation, replaces a redundant copy of a still-live variable with the original. Copy propagation can reduce the total number of live variables, reducing register pressure and memory usage, and possibly eliminating redundant memory-to-memory copies. In practice, both of these optimizations are implemented in nearly every modern compiler.These two optimizations are practical to implement and effective in first-order languages, but in languages with lexically-scoped first-class functions (aka, closures), these optimizations are not available to code programmed in a higher-order style. With higher-order functions, the analysis challenge has been that the environment at the call site must be the same as at the closure capture location, up to the free variables, or the meaning of the program may change. Olin Shivers' 1991 dissertation called this family of optimizations superΒ and he proposed one analysis technique, called reflow, to support these optimizations. Unfortunately, reflow has proven too expensive to implement in practice. Because these higher-order optimizations are not available in functional-language compilers, programmers studiously avoid uses of higher-order values that cannot be optimized (particularly in compiler benchmarks).This paper provides the first practical and effective technique for superΒ (higher-order) inlining and copy propagation, which we call unchanged variable analysis. We show that this technique is practical by implementing it in the context of a real compiler for an ML-family language and showing that the required analyses have costs below 3\% of the total compilation time. This technique's effectiveness is shown through a set of benchmarks and example programs, where this analysis exposes additional potential optimization sites.},
	booktitle = {Proceedings of the 19th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Bergstrom, Lars and Fluet, Matthew and Le, Matthew and Reppy, John and Sandler, Nora},
	year = {2014},
	note = {event-place: Gothenburg, Sweden},
	keywords = {control-flow analysis, inlining, optimization, to-read},
	pages = {81--93},
	file = {Bergstrom et al. - 2014 - Practical and Effective Higher-Order Optimizations.pdf:/Users/timwhiting/Zotero/storage/SYY5VMWX/Bergstrom et al. - 2014 - Practical and Effective Higher-Order Optimizations.pdf:application/pdf},
}

@inproceedings{might_shape_2010,
	title = {Shape analysis in the absence of pointers and structure},
	booktitle = {International {Workshop} on {Verification}, {Model} {Checking}, and {Abstract} {Interpretation}},
	publisher = {Springer},
	author = {Might, Matthew},
	year = {2010},
	keywords = {to-read},
	pages = {263--278},
	file = {Might - 2010 - Shape analysis in the absence of pointers and stru.pdf:/Users/timwhiting/Zotero/storage/BHF32VQP/Might - 2010 - Shape analysis in the absence of pointers and stru.pdf:application/pdf},
}

@inproceedings{plotkin_handlers_2009,
	title = {Handlers of algebraic effects},
	booktitle = {European {Symposium} on {Programming}},
	publisher = {Springer},
	author = {Plotkin, Gordon and Pretnar, Matija},
	year = {2009},
	keywords = {to-read},
	pages = {80--94},
	file = {Plotkin and Pretnar - 2009 - Handlers of algebraic effects.pdf:/Users/timwhiting/Zotero/storage/B5TC48XR/Plotkin and Pretnar - 2009 - Handlers of algebraic effects.pdf:application/pdf;Plotkin_Pretnar_2009_Handlers of algebraic effects2.pdf:/Users/timwhiting/Zotero/storage/L9J8DXFW/Plotkin_Pretnar_2009_Handlers of algebraic effects2.pdf:application/pdf},
}

@inproceedings{plotkin_logic_2008,
	title = {A logic for algebraic effects},
	booktitle = {2008 23rd {Annual} {IEEE} symposium on logic in computer science},
	publisher = {IEEE},
	author = {Plotkin, Gordon and Pretnar, Matija},
	year = {2008},
	keywords = {to-read},
	pages = {118--129},
	file = {Plotkin and Pretnar - 2008 - A logic for algebraic effects.pdf:/Users/timwhiting/Zotero/storage/6SGA8BDK/Plotkin and Pretnar - 2008 - A logic for algebraic effects.pdf:application/pdf},
}

@article{mine_octagon_2006,
	title = {The octagon abstract domain},
	volume = {19},
	journal = {Higher-order and symbolic computation},
	author = {Miné, Antoine},
	year = {2006},
	note = {Publisher: Springer},
	keywords = {to-read},
	pages = {31--100},
	file = {Miné - 2006 - The octagon abstract domain.pdf:/Users/timwhiting/Zotero/storage/SG75L3ZR/Miné - 2006 - The octagon abstract domain.pdf:application/pdf},
}

@article{author_context-sensitive_nodate,
	title = {Context-{Sensitive} {Demand}-{Driven} {Control}-{Flow} {Analysis}},
	language = {en},
	journal = {Flow Analysis},
	author = {Author, Anonymous},
	keywords = {to-read},
	file = {Author_Context-Sensitive Demand-Driven Control-Flow Analysis.pdf:/Users/timwhiting/Zotero/storage/KJE2L9YQ/Author_Context-Sensitive Demand-Driven Control-Flow Analysis.pdf:application/pdf;demand-cfa (1).rkt:/Users/timwhiting/Zotero/storage/4ABVI45L/demand-cfa (1).rkt:text/plain;paper.pdf:/home/tim/context-sensitive-demand-cfa/paper.pdf:application/pdf},
}

@article{duesterwald_practical_1997,
	title = {A practical framework for demand-driven interprocedural data flow analysis},
	volume = {19},
	number = {6},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Duesterwald, Evelyn and Gupta, Rajiv and Soffa, Mary Lou},
	year = {1997},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {992--1030},
	file = {Duesterwald et al. - 1997 - A practical framework for demand-driven interproce.pdf:/Users/timwhiting/Zotero/storage/6ULR935R/Duesterwald et al. - 1997 - A practical framework for demand-driven interproce.pdf:application/pdf},
}

@techreport{siskind_flow-directed_1999,
	title = {Flow-directed lightweight closure conversion},
	institution = {Technical Report 99-190R, NEC Research Institute, Inc},
	author = {Siskind, Jeffrey Mark},
	year = {1999},
	keywords = {to-read},
}

@article{dybvig_development_2006,
	title = {The development of chez scheme},
	volume = {41},
	number = {9},
	journal = {ACM SIGPLAN Notices},
	author = {Dybvig, R Kent},
	year = {2006},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--12},
}

@article{weeks_whole-program_2006,
	title = {Whole-program compilation in {MLton}},
	volume = {6},
	journal = {ML},
	author = {Weeks, Stephen},
	year = {2006},
	keywords = {to-read},
	pages = {1--1},
}

@article{karachalias_efficient_2021,
	title = {Efficient compilation of algebraic effect handlers},
	volume = {5},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Karachalias, Georgios and Koprivec, Filip and Pretnar, Matija and Schrijvers, Tom},
	year = {2021},
	note = {Publisher: Association for Computing Machinery (ACM)},
	keywords = {to-read},
	file = {Karachalias et al. - 2021 - Efficient compilation of algebraic effect handlers.pdf:/Users/timwhiting/Zotero/storage/LCPGJ7CJ/Karachalias et al. - 2021 - Efficient compilation of algebraic effect handlers.pdf:application/pdf},
}

@misc{noauthor_home_nodate,
	title = {Home},
	url = {https://effects.js.org/},
	abstract = {Algebraic Effects in Javascript},
	language = {en},
	urldate = {2023-09-11},
	keywords = {to-read},
	file = {Snapshot:/Users/timwhiting/Zotero/storage/HN9FLNEG/effects.js.org.html:text/html},
}

@misc{noauthor_effect_2023,
	title = {Effect},
	url = {https://effect.website/},
	abstract = {A fully-fledged functional effect system for TypeScript with a rich standard library},
	language = {en},
	urldate = {2023-09-11},
	month = aug,
	year = {2023},
	keywords = {to-read},
	file = {Snapshot:/Users/timwhiting/Zotero/storage/CID5CCYK/effect.website.html:text/html},
}

@article{brandl_modular_2023,
	title = {Modular {Abstract} {Definitional} {Interpreters} for {WebAssembly}},
	abstract = {Even though static analyses can improve performance and secure programs against vulnerabilities, no static whole-program analyses exist for WebAssembly (Wasm) to date. Part of the reason is that Wasm has many complex language concerns, and it is not obvious how to adopt existing analysis frameworks for these features. This paper explores how abstract definitional interpretation can be used to develop sophisticated analyses for Wasm and other complex languages efficiently. In particular, we show that the semantics of Wasm can be decomposed into 19 language-independent components that abstract different aspects of Wasm. We have written a highly configurable definitional interpreter for full Wasm 1.0 in 1628 LOC against these components. Analysis developers can instantiate this interpreter with different value and effect abstractions to obtain abstract definitional interpreters that compute inter-procedural control and data-flow information. This way, we develop the first whole-program dead code, constant propagation, and taint analyses for Wasm, each in less than 210 LOC. We evaluate our analyses on 1458 Wasm binaries collected by others in the wild. Our implementation is based on a novel framework for definitional abstract interpretation in Scala that eliminates scalability issues of prior work.},
	language = {en},
	author = {Brandl, Katharina and Erdweg, Sebastian and Keidel, Sven and Hansen, Nils},
	year = {2023},
	keywords = {to-read},
	file = {Brandl et al. - 2023 - Modular Abstract Definitional Interpreters for Web.pdf:/Users/timwhiting/Zotero/storage/UBY3M7LG/Brandl et al. - 2023 - Modular Abstract Definitional Interpreters for Web.pdf:application/pdf},
}

@article{xie_macocaml_2023,
	title = {{MacoCaml}: {Staging} {Composable} and {Compilable} {Macros}},
	volume = {7},
	url = {https://doi.org/10.1145/3607851},
	doi = {10.1145/3607851},
	abstract = {We introduce MacoCaml, a new design and implementation of compile-time code generation for the OCaml language. MacoCaml features a novel combination of macros with phase separation and quotation-based staging, where macros are considered as compile-time bindings, expression cross evaluation phases using staging annotations, and compile-time evaluation happens inside top-level splices. We provide a theoretical foundation for MacoCaml by formalizing a typed source calculus maco that supports interleaving typing and compile-time code generation, references with explicit compile-time heaps, and modules. We study various crucial properties including soundness and phase distinction. We have implemented MacoCaml in the OCaml compiler, and ported two substantial existing libraries to validate our implementation.},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Xie, Ningning and White, Leo and Nicole, Olivier and Yallop, Jeremy},
	month = aug,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Compile-time code generation, Macros, OCaml, Staging, to-read},
	file = {Xie et al. - 2023 - MacoCaml Staging Composable and Compilable Macros.pdf:/Users/timwhiting/Zotero/storage/BTHWANWR/Xie et al. - 2023 - MacoCaml Staging Composable and Compilable Macros.pdf:application/pdf},
}

@inproceedings{lindley_algebraic_2014,
	address = {New York, NY, USA},
	series = {{WGP} '14},
	title = {Algebraic {Effects} and {Effect} {Handlers} for {Idioms} and {Arrows}},
	isbn = {978-1-4503-3042-8},
	url = {https://doi.org/10.1145/2633628.2633636},
	doi = {10.1145/2633628.2633636},
	abstract = {Plotkin and Power's algebraic effects combined with Plotkin and Pretnar's effect handlers provide a foundation for modular programming with effects. We present a generalisation of algebraic effects and effect handlers to support other kinds of effectful computations corresponding to McBride and Paterson's idioms and Hughes' arrows.},
	booktitle = {Proceedings of the 10th {ACM} {SIGPLAN} {Workshop} on {Generic} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Lindley, Sam},
	year = {2014},
	note = {event-place: Gothenburg, Sweden},
	keywords = {algebraic effects, applicative functors, arrows, call-by-push-value, effect handlers, idioms, monads, to-read},
	pages = {47--58},
	file = {Lindley - 2014 - Algebraic Effects and Effect Handlers for Idioms a.pdf:/Users/timwhiting/Zotero/storage/XXF3T69A/Lindley - 2014 - Algebraic Effects and Effect Handlers for Idioms a.pdf:application/pdf},
}

@article{hughes_generalising_2000,
	title = {Generalising monads to arrows},
	volume = {37},
	issn = {0167-6423},
	url = {https://www.sciencedirect.com/science/article/pii/S0167642399000234},
	doi = {https://doi.org/10.1016/S0167-6423(99)00023-4},
	abstract = {Monads have become very popular for structuring functional programs since Wadler introduced their use in 1990. In particular, libraries of combinators are often based on a monadic type. Such libraries share (in part) a common interface, from which numerous benefits flow, such as the possibility to write generic code which works together with any library. But, several interesting and useful libraries are fundamentally incompatible with the monadic interface. In this paper I propose a generalisation of monads, which I call arrows, with significantly wider applicability. The paper shows how many of the techniques of monadic programming generalise to the new setting, and gives examples to show that the greater generality is useful. In particular, three non-monadic libraries for efficient parsing, building graphical user interfaces, and programming active web pages fit naturally into the new framework.},
	number = {1},
	journal = {Science of Computer Programming},
	author = {Hughes, John},
	year = {2000},
	keywords = {to-read},
	pages = {67--111},
	file = {Hughes - 2000 - Generalising monads to arrows.pdf:/Users/timwhiting/Zotero/storage/T6HY3WMY/Hughes - 2000 - Generalising monads to arrows.pdf:application/pdf},
}

@inproceedings{xie_haskell_2023,
	address = {New York, NY, USA},
	series = {Haskell 2023},
	title = {Haskell for {Choice}-{Based} {Learning} ({Keynote})},
	isbn = {9798400702983},
	url = {https://doi.org/10.1145/3609026.3615580},
	doi = {10.1145/3609026.3615580},
	abstract = {Machine learning has achieved many successes during the past decades, spanning domains of game-playing, protein folding, competitive programming, and many others. However, while there have been major efforts in building programming techniques and frameworks for machine learning programming, there has been very little study of general language design for machine learning programming. We pursue such a study in this talk, focusing on choice-based learning, particularly where choices are driven by optimizations. This includes widely-used decision-making models and techniques (e.g., Markov decision processes or gradient descent) which provide frameworks for describing systems in terms of choices (e.g., actions or parameters) and their resulting feedback as losses (dually, rewards). We propose and give evidence for the following thesis: languages for choice-based learning can be obtained by combining two paradigms, algebraic effects and handlers, and the selection monad. We provide a prototype implementation as a Haskell library and present a variety of programming examples for choice-based learning: stochastic gradient descent, hyperparameter tuning, generative adversarial networks, and reinforcement learning.},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} {International} {Haskell} {Symposium}},
	publisher = {Association for Computing Machinery},
	author = {Xie, Ningning},
	year = {2023},
	note = {event-place: Seattle, WA, USA},
	keywords = {to-read},
	pages = {1},
}

@article{pinto_exploring_nodate,
	title = {Exploring {Perceus} {For} {OCaml}},
	language = {en},
	author = {Pinto, Elton and Leijen, Daan},
	keywords = {to-read},
	file = {Pinto and Leijen - Exploring Perceus For OCaml.pdf:/Users/timwhiting/Zotero/storage/MLLBRNVX/Pinto and Leijen - Exploring Perceus For OCaml.pdf:application/pdf},
}

@inproceedings{nguyen_effect_2023,
	address = {New York, NY, USA},
	series = {Haskell 2023},
	title = {Effect {Handlers} for {Programmable} {Inference}},
	isbn = {9798400702983},
	url = {https://doi.org/10.1145/3609026.3609729},
	doi = {10.1145/3609026.3609729},
	abstract = {Inference algorithms for probabilistic programming are complex imperative programs with many moving parts. Efficient inference often requires customising an algorithm to a particular probabilistic model or problem, sometimes called inference programming. Most inference frameworks are implemented in languages that lack a disciplined approach to side effects, which can result in monolithic implementations where the structure of the algorithms is obscured and inference programming is hard. Functional programming with typed effects offers a more structured and modular foundation for programmable inference, with monad transformers being the primary structuring mechanism explored to date. This paper presents an alternative approach to inference programming based on algebraic effects. Using effect signatures to specify the key operations of the algorithms, and effect handlers to modularly interpret those operations for specific variants, we develop two abstract algorithms, or inference patterns, representing two important classes of inference: Metropolis-Hastings and particle filtering. We show how our approach reveals the algorithms’ high-level structure, and makes it easy to tailor and recombine their parts into new variants. We implement the two inference patterns as a Haskell library, and discuss the pros and cons of algebraic effects vis-à-vis monad transformers as a structuring mechanism for modular imperative algorithm design.},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} {International} {Haskell} {Symposium}},
	publisher = {Association for Computing Machinery},
	author = {Nguyen, Minh and Perera, Roly and Wang, Meng and Ramsay, Steven},
	year = {2023},
	note = {event-place: Seattle, WA, USA},
	keywords = {algebraic effects, functional programming, modularity, probabilistic programming, to-read},
	pages = {44--58},
	file = {Nguyen et al. - 2023 - Effect Handlers for Programmable Inference.pdf:/Users/timwhiting/Zotero/storage/KBYXTB5E/Nguyen et al. - 2023 - Effect Handlers for Programmable Inference.pdf:application/pdf},
}

@inproceedings{wu_evolution_2023,
	address = {New York, NY, USA},
	series = {Haskell 2023},
	title = {The {Evolution} of {Effects} ({Keynote})},
	isbn = {9798400702983},
	url = {https://doi.org/10.1145/3609026.3615581},
	doi = {10.1145/3609026.3615581},
	abstract = {Functional programming has been celebrated for its promise of pure functions, delivering referential transparency and elegant reasoning about programs. However, real-world applications are not pure, and necessitate interaction with the outside world, introducing computational effects such as IO, state, and exceptions. The journey to harmonize these seemingly contradictory paradigms has led to a fascinating evolution of effectful programming in Haskell. The introduction of monads as a practical programming tool was a pivotal discovery, enabling controlled sequencing of effectful computations and addressing the challenge of handling side effects in a pure language. However, it soon became evident that the lack of modularity in composing effects using monads posed a limitation to effectful programming. To overcome this obstacle, monad transformers emerged as a solution, providing a composable manner of building effects on top of one another. More recent advancements have led to algebraic effects as an alternative framework that is easy to extend, particularly as domain-specific languages crafted to work in specific contexts. Nevertheless, these effects are not without quirks and limitations, leading to the development of higher-order effects. These higher-order effects extend the capabilities of algebraic effects, providing greater flexibility for expressing effectful computations, while also shedding light on the connection between the monad approach and the algebraic approach to effects. This talk will survey the historical milestones that have shaped the landscape of effectful programming in Haskell, exploring the transition from monads to monad transformers and the emergence of algebraic and higher-order effects.},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} {International} {Haskell} {Symposium}},
	publisher = {Association for Computing Machinery},
	author = {Wu, Nicolas},
	year = {2023},
	note = {event-place: Seattle, WA, USA},
	keywords = {to-read},
	pages = {2},
	file = {Wu - 2023 - The Evolution of Effects (Keynote).pdf:/Users/timwhiting/Zotero/storage/G92EUW56/Wu - 2023 - The Evolution of Effects (Keynote).pdf:application/pdf},
}

@article{hubers_generic_2023,
	title = {Generic {Programming} with {Extensible} {Data} {Types}: {Or}, {Making} {Ad} {Hoc} {Extensible} {Data} {Types} {Less} {Ad} {Hoc}},
	volume = {7},
	url = {https://doi.org/10.1145/3607843},
	doi = {10.1145/3607843},
	abstract = {We present a novel approach to generic programming over extensible data types. Row types capture the structure of records and variants, and can be used to express record and variant subtyping, record extension, and modular composition of case branches. We extend row typing to capture generic programming over rows themselves, capturing patterns including lifting operations to records and variations from their component types, and the duality between cases blocks over variants and records of labeled functions, without placing specific requirements on the fields or constructors present in the records and variants. We formalize our approach in System R𝜔, an extension of F𝜔 with row types, and give a denotational semantics for (stratified) R𝜔 in Agda.},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Hubers, Alex and Morris, J. Garrett},
	month = aug,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {extensible data types, generic programming, qualified types, row polymorphism, row types, to-read},
	file = {Hubers and Morris - 2023 - Generic Programming with Extensible Data Types Or.pdf:/Users/timwhiting/Zotero/storage/5GRVM9CX/Hubers and Morris - 2023 - Generic Programming with Extensible Data Types Or.pdf:application/pdf},
}

@article{keidel_combinator-based_2023,
	title = {Combinator-{Based} {Fixpoint} {Algorithms} for {Big}-{Step} {Abstract} {Interpreters}},
	volume = {7},
	url = {https://doi.org/10.1145/3607863},
	doi = {10.1145/3607863},
	abstract = {Big-step abstract interpreters are an approach to build static analyzers based on big-step interpretation. While big-step interpretation provides a number of benefits for the definition of an analysis, it also requires particularly complicated fixpoint algorithms because the analysis definition is a recursive function whose termination is uncertain. This is in contrast to other analysis approaches, such as small-step reduction, abstract machines, or graph reachability, where the analysis essentially forms a finite transition system between widened analysis states. We show how to systematically develop sophisticated fixpoint algorithms for big-step abstract interpreters and how to ensure their soundness. Our approach is based on small and reusable fixpoint combinators that can be composed to yield fixpoint algorithms. For example, these combinators describe the order in which the program is analyzed, how deep recursive functions are unfolded and loops unrolled, or they record auxiliary data such as a (context-sensitive) call graph. Importantly, each combinator can be developed separately, reused across analyses, and can be verified sound independently. Consequently, analysis developers can freely compose combinators to obtain sound fixpoint algorithms that work best for their use case. We provide a formal metatheory that guarantees a fixpoint algorithm is sound if its composed from sound combinators only. We experimentally validate our combinator-based approach by describing sophisticated fixpoint algorithms for analyses of Stratego, Scheme, and WebAssembly.},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Keidel, Sven and Erdweg, Sebastian and Hombücher, Tobias},
	month = aug,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Static Analysis, Big-Step Abstract Interpretation, Fixpoint Algorithm, to-read},
	file = {Keidel et al. - 2023 - Combinator-Based Fixpoint Algorithms for Big-Step .pdf:/Users/timwhiting/Zotero/storage/TGC6RY9K/Keidel et al. - 2023 - Combinator-Based Fixpoint Algorithms for Big-Step .pdf:application/pdf},
}

@misc{akinshin_statistical_2020,
	title = {Statistical approaches for performance analysis},
	url = {https://aakinshin.net/posts/statistics-for-performance/},
	urldate = {2023-09-12},
	author = {Akinshin, Andrey},
	month = dec,
	year = {2020},
	keywords = {to-read},
}

@article{sieczkowski_general_2023,
	title = {A {General} {Fine}-{Grained} {Reduction} {Theory} for {Effect} {Handlers}},
	volume = {7},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Sieczkowski, Filip and Pyzik, Mateusz and Biernacki, Dariusz},
	year = {2023},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {extra-to-read},
	pages = {511--540},
	file = {Sieczkowski et al. - 2023 - A General Fine-Grained Reduction Theory for Effect.pdf:/Users/timwhiting/Zotero/storage/WSJLKG7E/Sieczkowski et al. - 2023 - A General Fine-Grained Reduction Theory for Effect.pdf:application/pdf},
}

@inproceedings{schwarz_when_2023,
	address = {New York, NY, USA},
	series = {{SOAP} 2023},
	title = {When {Long} {Jumps} {Fall} {Short}: {Control}-{Flow} {Tracking} and {Misuse} {Detection} for {Non}-{Local} {Jumps} in {C}},
	isbn = {9798400701702},
	url = {https://doi.org/10.1145/3589250.3596140},
	doi = {10.1145/3589250.3596140},
	abstract = {The C programming language offers setjmp/longjmp as a mechanism for non-local control flow. This mechanism has complicated semantics. As most developers do not encounter it day-to-day, they may be unfamiliar with all its intricacies – leading to subtle programming errors. At the same time, most static analyzers lack proper support, implying that otherwise sound tools miss whole classes of program deficiencies. We propose an approach for lifting existing interprocedural analyses to support setjmp/longjmp, as well as to flag their misuse. To deal with the non-local semantics, our approach leverages side-effecting transfer functions which, when executed, may trigger contributions to extra program points. We showcase our analysis on real-world examples and propose a set of litmus tests for other analyzers.},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} {International} {Workshop} on the {State} {Of} the {Art} in {Program} {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Schwarz, Michael and Erhard, Julian and Vojdani, Vesal and Saan, Simmo and Seidl, Helmut},
	year = {2023},
	note = {event-place: Orlando, FL, USA},
	keywords = {Abstract Interpretation, Static Analysis, setjmp / longjmp, Side-Effects, to-read},
	pages = {20--26},
	file = {Schwarz et al. - 2023 - When Long Jumps Fall Short Control-Flow Tracking .pdf:/Users/timwhiting/Zotero/storage/RCSAZW5C/Schwarz et al. - 2023 - When Long Jumps Fall Short Control-Flow Tracking .pdf:application/pdf},
}

@inproceedings{negrini_static_2023,
	address = {New York, NY, USA},
	series = {{SOAP} 2023},
	title = {Static {Analysis} of {Data} {Transformations} in {Jupyter} {Notebooks}},
	isbn = {9798400701702},
	url = {https://doi.org/10.1145/3589250.3596145},
	doi = {10.1145/3589250.3596145},
	abstract = {Jupyter notebooks used to pre-process and polish raw data for data science and machine learning processes are challenging to analyze. Their data-centric code manipulates dataframes through call to library functions with complex semantics, and the properties to track over it vary widely depending on the verification task. This paper presents a novel abstract domain that simplifies writing analyses for such programs, by extracting a unique CFG from the notebook that contains all transformations applied to the data. Several properties can then be determined by analyzing such CFG, that is simpler than the original Python code. We present a first use case that exploits our analysis to infer the required shape of the dataframes manipulated by the notebook.},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} {International} {Workshop} on the {State} {Of} the {Art} in {Program} {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Negrini, Luca and Shabadi, Guruprerana and Urban, Caterina},
	year = {2023},
	note = {event-place: Orlando, FL, USA},
	keywords = {Abstract Interpretation, Static Analysis, Data Science, Jupyter Notebooks, to-read},
	pages = {8--13},
	file = {Negrini et al. - 2023 - Static Analysis of Data Transformations in Jupyter.pdf:/Users/timwhiting/Zotero/storage/I2ZQD8LE/Negrini et al. - 2023 - Static Analysis of Data Transformations in Jupyter.pdf:application/pdf},
}

@inproceedings{coward_combining_2023,
	address = {New York, NY, USA},
	series = {{SOAP} 2023},
	title = {Combining {E}-{Graphs} with {Abstract} {Interpretation}},
	isbn = {9798400701702},
	url = {https://doi.org/10.1145/3589250.3596144},
	doi = {10.1145/3589250.3596144},
	abstract = {E-graphs are a data structure that compactly represents equivalent expressions. They are constructed via the repeated application of rewrite rules. Often in practical applications, conditional rewrite rules are crucial, but their application requires the detection – at the time the e-graph is being built – that a condition is valid in the domain of application. Detecting condition validity amounts to proving a property of the program. Abstract interpretation is a general method to learn such properties, traditionally used in static analysis tools. We demonstrate that abstract interpretation and e-graph analysis naturally reinforce each other through a tight integration because (i) the e-graph clustering of equivalent expressions induces natural precision refinement of abstractions and (ii) precise abstractions allow the application of deeper rewrite rules (and hence potentially even greater precision). We develop the theory behind this intuition and present an exemplar interval arithmetic implementation, which we apply to the FPBench suite.},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} {International} {Workshop} on the {State} {Of} the {Art} in {Program} {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Coward, Samuel and Constantinides, George A. and Drane, Theo},
	year = {2023},
	note = {event-place: Orlando, FL, USA},
	keywords = {abstract interpretation, e-graph, interval arithmetic, static analysis, to-read},
	pages = {1--7},
	file = {Coward et al. - 2023 - Combining E-Graphs with Abstract Interpretation.pdf:/Users/timwhiting/Zotero/storage/7BBQBA7K/Coward et al. - 2023 - Combining E-Graphs with Abstract Interpretation.pdf:application/pdf},
}

@article{germane_demand_nodate,
	title = {{DEMAND} {ENVIRONMENT} {ANALYSIS} {OF} {HIGHER}-{ORDER} {LANGUAGES}},
	language = {en},
	author = {Germane, Kimball Richard},
	keywords = {to-read},
	file = {Germane - DEMAND ENVIRONMENT ANALYSIS OF HIGHER-ORDER LANGUA.pdf:/Users/timwhiting/Zotero/storage/Y9U99WBP/Germane - DEMAND ENVIRONMENT ANALYSIS OF HIGHER-ORDER LANGUA.pdf:application/pdf},
}

@article{waddell_fast_nodate,
	title = {Fast and {Effective} {Procedure} {Inlining}},
	abstract = {Inlining is an important optimization for programs that use procedural abstraction. Because inlining trades code size for execution speed, the e ectiveness of an inlining algorithm is determined not only by its ability to recognize inlining opportunities but also by its discretion in exercising those opportunities. This paper presents a new inlining algorithm for higher-order languages that combines simple analysis techniques with demand-driven online transformation to achieve consistent and often dramatic performance gains in fast linear time. Benchmark results reported here demonstrate that this inlining algorithm is as e ective as and signi cantly faster than o ine, analysis-intensive algorithms recently described in the literature.},
	language = {en},
	author = {Waddell, Oscar and Dybvig, R Kent},
	keywords = {to-read},
	file = {Waddell and Dybvig - Fast and Effective Procedure Inlining.pdf:/Users/timwhiting/Zotero/storage/6APJVM5A/Waddell and Dybvig - Fast and Effective Procedure Inlining.pdf:application/pdf},
}

@inproceedings{lewis_implicit_2000,
	address = {Boston MA USA},
	title = {Implicit parameters: dynamic scoping with static types},
	isbn = {978-1-58113-125-3},
	shorttitle = {Implicit parameters},
	url = {https://dl.acm.org/doi/10.1145/325694.325708},
	doi = {10.1145/325694.325708},
	abstract = {This paper introduces a language feature, called implicit parameters, that provides dynamically scoped variables within a statically-typed Hindley-Milner framework. Implicit parameters are lexically distinct from regular identifiers, and are bound by a special with construct whose scope is dynamic, rather than static as with let. Implicit parameters are treated by the type system as parameters that are not explicitly declared, but are inferred from their use. We present implicit parameters within a small call-by-name X-calculus. We give a type system, a type inference algorithm, and several semantics. We also explore implicit parameters in the wider settings of call-by-need languages with overloading, and call-by-value languages with effects. As a witness to the former, we have implemented implicit parameters as an extension of Haskell within the Hugs interpreter, which we use to present several motivating examples.},
	language = {en},
	urldate = {2023-10-23},
	booktitle = {Proceedings of the 27th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	publisher = {ACM},
	author = {Lewis, Jeffrey R. and Launchbury, John and Meijer, Erik and Shields, Mark B.},
	month = jan,
	year = {2000},
	keywords = {to-read},
	pages = {108--118},
	file = {Lewis et al. - 2000 - Implicit parameters dynamic scoping with static t.pdf:/Users/timwhiting/Zotero/storage/9ZJZPJWY/Lewis et al. - 2000 - Implicit parameters dynamic scoping with static t.pdf:application/pdf},
}

@article{spath_context-_2019,
	title = {Context-, flow-, and field-sensitive data-flow analysis using synchronized {Pushdown} systems},
	volume = {3},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3290361},
	doi = {10.1145/3290361},
	abstract = {Precise static analyses are context-, field- and flow-sensitive. Context- and field-sensitivity are both expressible as context-free language (CFL) reachability problems. Solving both CFL problems along the same data-flow path is undecidable, which is why most flow-sensitive data-flow analyses over-approximate field-sensitivity through
              k
              -limited access-path, or through access graphs. Unfortunately, as our experience and this paper show, both representations do not scale very well when used to analyze programs with recursive data structures.
            
            Any single CFL-reachability problem is efficiently solvable, by means of a pushdown system. This work thus introduces the concept of synchronized pushdown systems (SPDS). SPDS encode both procedure calls/returns and field stores/loads as separate but “synchronized” CFL reachability problems. An SPDS solves both individual problems precisely, and approximation occurs only in corner cases that are apparently rare in practice: at statements where both problems are satisfied but not along the same data-flow path.
            
              SPDS are also efficient: formal complexity analysis shows that SPDS shift the complexity from {\textbar}
              F
              {\textbar}
              
                3
                k
              
              under
              k
              -limiting to {\textbar}
              S
              {\textbar}{\textbar}
              F
              {\textbar}
              2
              , where
              F
              is the set of fields and
              S
              the set of statements involved in a data-flow. Our evaluation using DaCapo shows this shift to pay off in practice: SPDS are almost as efficient as
              k
              -limiting with
              k
              =1 although their precision equals
              k
              =∞. For a typestate analysis SPDS accelerate the analysis up to 83× for data-flows of objects that involve many field accesses but span rather few methods.
            
            We conclude that SPDS can provide high precision and further improve scalability, in particularly when used in analyses that expose rather local data flows.},
	language = {en},
	number = {POPL},
	urldate = {2023-10-25},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Späth, Johannes and Ali, Karim and Bodden, Eric},
	month = jan,
	year = {2019},
	keywords = {to-read},
	pages = {1--29},
	file = {Späth et al. - 2019 - Context-, flow-, and field-sensitive data-flow ana.pdf:/Users/timwhiting/Zotero/storage/73EI3H6A/Späth et al. - 2019 - Context-, flow-, and field-sensitive data-flow ana.pdf:application/pdf},
}

@incollection{hermenegildo_lifting_2023,
	address = {Cham},
	title = {Lifting {On}-{Demand} {Analysis} to {Higher}-{Order} {Languages}},
	volume = {14284},
	isbn = {978-3-031-44244-5 978-3-031-44245-2},
	url = {https://link.springer.com/10.1007/978-3-031-44245-2_20},
	abstract = {In this paper, we present an approach to lift on-demand analysis to higher-order languages. Specifically, our approach bootstraps an on-demand call graph construction by leveraging a pair of on-demand data flow analyses. Static analysis is increasingly applied to find subtle bugs or prove deep properties in large, industrial code bases. To effectively do this at scale, analyzers need to both resolve function calls in a precise manner (i.e., construct a precise call graph) and examine only the relevant portion of the program (i.e., be on-demand). A strawman strategy to this problem is to use fast, approximate, whole-program call graph construction algorithms. However, this strategy is generally not adequate for modern languages like JavaScript that rely heavily on higher-order features, such as callbacks and closures, where scalable approximations often introduce unacceptable imprecision. This strategy also limits increasingly sophisticated on-demand analyses, which scale by analyzing only parts of a program as needed: the scalability advantages of an ondemand analysis may be thwarted by the need to construct a wholeprogram call graph. The key insight of this paper is that existing ondemand data flow analyses can themselves be applied in a black-box manner to construct call graphs on demand. We propose a soundness condition for the existing on-demand analyses with respect to partial call graphs, formalize our algorithm as an abstract domain combinator, and prove it sound in Isabelle/HOL. Furthermore, we evaluate a prototype implementation of the resulting on-demand call graph construction algorithm for a subset of JavaScript (using the Synchronized Push-Down Systems framework as the underlying data flow analysis) on benchmarks making heavy use of higher-order functions.},
	language = {en},
	urldate = {2023-10-25},
	booktitle = {Static {Analysis}},
	publisher = {Springer Nature Switzerland},
	author = {Schoepe, Daniel and Seekatz, David and Stoilkovska, Ilina and Stucki, Sandro and Tattersall, Daniel and Bolignano, Pauline and Raimondi, Franco and Chang, Bor-Yuh Evan},
	editor = {Hermenegildo, Manuel V. and Morales, José F.},
	year = {2023},
	doi = {10.1007/978-3-031-44245-2_20},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {to-read},
	pages = {460--484},
	file = {Schoepe et al. - 2023 - Lifting On-Demand Analysis to Higher-Order Languag.pdf:/Users/timwhiting/Zotero/storage/68VTF4LR/Schoepe et al. - 2023 - Lifting On-Demand Analysis to Higher-Order Languag.pdf:application/pdf},
}

@inproceedings{oliveira_type_2010,
	address = {New York, NY, USA},
	series = {{OOPSLA} '10},
	title = {Type {Classes} as {Objects} and {Implicits}},
	isbn = {978-1-4503-0203-6},
	url = {https://doi.org/10.1145/1869459.1869489},
	doi = {10.1145/1869459.1869489},
	abstract = {Type classes were originally developed in Haskell as a disciplined alternative to ad-hoc polymorphism. Type classes have been shown to provide a type-safe solution to important challenges in software engineering and programming languages such as, for example, retroactive extension of programs. They are also recognized as a good mechanism for concept-based generic programming and, more recently, have evolved into a mechanism for type-level computation.This paper presents a lightweight approach to type classes in object-oriented (OO) languages with generics using the CONCEPT pattern and implicits (a type-directed implicit parameter passing mechanism). This paper also shows how Scala's type system conspires with implicits to enable, and even surpass, many common extensions of the Haskell type class system, making Scala ideally suited for generic programming in the large.},
	booktitle = {Proceedings of the {ACM} {International} {Conference} on {Object} {Oriented} {Programming} {Systems} {Languages} and {Applications}},
	publisher = {Association for Computing Machinery},
	author = {Oliveira, Bruno C.d.S. and Moors, Adriaan and Odersky, Martin},
	year = {2010},
	note = {event-place: Reno/Tahoe, Nevada, USA},
	keywords = {abstract datatypes, c++ concepts, scala, type classes, to-read},
	pages = {341--360},
	file = {Oliveira et al. - 2010 - Type Classes as Objects and Implicits.pdf:/Users/timwhiting/Zotero/storage/9C66UMN5/Oliveira et al. - 2010 - Type Classes as Objects and Implicits.pdf:application/pdf},
}

@incollection{swierstra_sound_2022,
	address = {Cham},
	title = {Sound and {Complete} {Type} {Inference} for {Closed} {Effect} {Rows}},
	volume = {13401},
	isbn = {978-3-031-21313-7 978-3-031-21314-4},
	url = {https://link.springer.com/10.1007/978-3-031-21314-4_8},
	abstract = {Koka is a functional programming language that has algebraic eﬀect handlers and a row-based eﬀect system. The row-based eﬀect system infers types by naively applying the Hindley-Milner type inference. However, it infers eﬀect-polymorphic types for many functions, which are hard to read by the programmers and have a negative runtime performance impact to the evidence-passing translation. In order to improve readability and runtime eﬃciency, we aim to infer closed eﬀect rows when possible, and open those closed eﬀect rows automatically at instantiation to avoid loss of typability. This paper gives a type inference algorithm with the open and close mechanisms. In this paper, we deﬁne a type inference algorithm with the open and close constructs.},
	language = {en},
	urldate = {2023-11-04},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer International Publishing},
	author = {Ikemori, Kazuki and Cong, Youyou and Masuhara, Hidehiko and Leijen, Daan},
	editor = {Swierstra, Wouter and Wu, Nicolas},
	year = {2022},
	doi = {10.1007/978-3-031-21314-4_8},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {to-read},
	pages = {144--168},
	file = {Ikemori et al_2022_Sound and Complete Type Inference for Closed Effect Rows.pdf:/Users/timwhiting/Zotero/storage/DJM2GGQV/Ikemori et al_2022_Sound and Complete Type Inference for Closed Effect Rows.pdf:application/pdf;Ikemori et al_2023_Sound and Complete Type Inference for Closed Effect Rows.pdf:/Users/timwhiting/Zotero/storage/FL2CINY8/Ikemori et al_2023_Sound and Complete Type Inference for Closed Effect Rows.pdf:application/pdf},
}

@incollection{swierstra_towards_2022,
	address = {Cham},
	title = {Towards {Efficient} {Adjustment} of {Effect} {Rows}},
	volume = {13401},
	isbn = {978-3-031-21313-7 978-3-031-21314-4},
	url = {https://link.springer.com/10.1007/978-3-031-21314-4_9},
	abstract = {Koka is a functional programming language with native support for algebraic eﬀects and handlers. To implement eﬀect handler operations eﬃciently, Koka employs a semantics where the handlers in scope are passed down to each function as an evidence vector. At runtime, these evidence vectors are adjusted using the open constructs to match the evidence for a particular function. All these adjustments can cause signiﬁcant runtime overhead. In this paper, we present a novel transformation on the Koka core calculus that we call open ﬂoating. This transformation aims to ﬂoat up open constructs and combine them in order to minimize the adjustments needed at runtime. Open ﬂoating improves performance by 2.5× in an experiment. Furthermore, we formalize an aspect of row-based eﬀect typing, including the closed preﬁx relation on eﬀect rows, which clariﬁes the constraint on open ﬂoating.},
	language = {en},
	urldate = {2023-11-04},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer International Publishing},
	author = {Furudono, Naoya and Cong, Youyou and Masuhara, Hidehiko and Leijen, Daan},
	editor = {Swierstra, Wouter and Wu, Nicolas},
	year = {2022},
	doi = {10.1007/978-3-031-21314-4_9},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {to-read},
	pages = {169--191},
	file = {Furudono et al_2023_Towards Efficient Adjustment of Effect Rows.pdf:/Users/timwhiting/Zotero/storage/SSRRGFG3/Furudono et al_2023_Towards Efficient Adjustment of Effect Rows.pdf:application/pdf;Furudono et al. - 2022 - Towards Efficient Adjustment of Effect Rows.pdf:/Users/timwhiting/Zotero/storage/TYVWNXLB/Furudono et al. - 2022 - Towards Efficient Adjustment of Effect Rows.pdf:application/pdf},
}

@misc{smith_pure_2023,
	title = {A {Pure} {Demand} {Operational} {Semantics} {With} {Applications} to {Program} {Analysis}},
	url = {http://arxiv.org/abs/2310.15915},
	abstract = {This paper develops a novel minimal-state operational semantics for higher-order functional languages which uses only the call stack and two source program points as the complete state information: there is no environment, no substitution, no continuation, etc. We prove this form of operational semantics is equivalent to standard presentations. We then show how this approach can open the door to potential new applications: we define a program analysis as a direct finitization of this operational semantics. The program analysis that naturally emerges has a number of novel and interesting properties compared to standard program analyses for higher-order programs: for example, it can infer recurrences, and does not need value widening. We both give a formal definition of the analysis and describe our current implementation.},
	language = {en},
	urldate = {2023-12-12},
	publisher = {arXiv},
	author = {Smith, Scott and Zhang, Robert},
	month = oct,
	year = {2023},
	note = {arXiv:2310.15915 [cs]},
	keywords = {Computer Science - Programming Languages, to-read},
	file = {Smith and Zhang - 2023 - A Pure Demand Operational Semantics With Applicati.pdf:/Users/timwhiting/Zotero/storage/ZQW2UE7D/Smith and Zhang - 2023 - A Pure Demand Operational Semantics With Applicati.pdf:application/pdf},
}

@article{boucher_lightweight_nodate,
	title = {Lightweight {Preemptible} {Functions}},
	abstract = {Lamenting the lack of a natural userland abstraction for preemptive interruption and asynchronous cancellation, we propose lightweight preemptible functions, a mechanism for synchronously performing a function call with a precise timeout that is lightweight, e cient, and composable, all while being portable between programming languages. We present the design of libinger, a library that provides this abstraction, on top of which we build libturquoise, arguably the rst generalpurpose and backwards-compatible preemptive thread library implemented entirely in userland. Finally, we demonstrate this software stack’s applicability to and performance on the problems of combatting head-ofline blocking and time-based DoS attacks.},
	language = {en},
	author = {Boucher, Sol and Kalia, Anuj and Andersen, David G and Kaminsky, Michael},
	keywords = {to-read},
	file = {Boucher et al. - Lightweight Preemptible Functions.pdf:/Users/timwhiting/Zotero/storage/JBI2JB2D/Boucher et al. - Lightweight Preemptible Functions.pdf:application/pdf},
}

@article{jonest_yale_nodate,
	title = {Yale {University} {Department} of {Computer} {Science} {New} {Haven}, {CT} 06520-8285},
	abstract = {We show howa set of building blocks can be used to construct programming language interpreters, and present implementations of such building blocks capable of supporting many commonly known features, including simple expressions, three different function call mechanisms (call-by-name, callby-value and lazy evaluation), references and assignment, nondeterminism, first-class continuations, and program tracing. The underlying mechanism of our system is monad fransfonners, a simple form of abstraction for introducing a wide range of computational behaviors, such as state, 1/0, continuations, and exceptions.},
	language = {en},
	author = {Jonest, Mark},
	keywords = {to-read},
	file = {Jonest - Yale University Department of Computer Science New.pdf:/Users/timwhiting/Zotero/storage/AANSHRFY/Jonest - Yale University Department of Computer Science New.pdf:application/pdf},
}

@article{thomson_fusing_2022,
	title = {Fusing industry and academia at {GitHub} (experience report)},
	volume = {6},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3547639},
	doi = {10.1145/3547639},
	abstract = {PATRICK THOMSON, GitHub, Inc., United States ROB RIX, GitHub, Inc., Canada NICOLAS WU, Imperial College London, United Kingdom TOM SCHRIJVERS, KU Leuven, Belgium GitHub hosts hundreds of millions of code repositories written in hundreds of different programming languages. In addition to its hosting services, GitHub provides data and insights into code, such as vulnerability analysis and code navigation, with which users can improve and understand their software development process. GitHub has built Semantic, a program analysis tool capable of parsing and extracting detailed information from source code. The development of Semantic has relied extensively on the functional programming literature; this paper describes how connections to academic research inspired and informed the development of an industrial-scale program analysis toolkit. CCS Concepts: · Software and its engineering → General programming languages; · Social and professional topics → History of programming languages.},
	language = {en},
	number = {ICFP},
	urldate = {2024-01-10},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Thomson, Patrick and Rix, Rob and Wu, Nicolas and Schrijvers, Tom},
	month = aug,
	year = {2022},
	keywords = {to-read},
	pages = {496--511},
	file = {Thomson et al. - 2022 - Fusing industry and academia at GitHub (experience.pdf:/Users/timwhiting/Zotero/storage/IA9HPMUD/Thomson et al. - 2022 - Fusing industry and academia at GitHub (experience.pdf:application/pdf},
}

@article{whiting_proving_nodate,
	title = {Proving {Out} {Demand} {CFA} for {Modern} {Compiler} {Architectures}},
	language = {en},
	author = {Whiting, Tim},
	keywords = {to-read},
	file = {Whiting - Proving Out Demand CFA for Modern Compiler Archite.pdf:/Users/timwhiting/Zotero/storage/H5LE69II/Whiting - Proving Out Demand CFA for Modern Compiler Archite.pdf:application/pdf},
}

@article{van_horn_deciding_2008,
	title = {Deciding {KCFA} is {Complete} for {EXPTIME}},
	volume = {43},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/1411203.1411243},
	doi = {10.1145/1411203.1411243},
	abstract = {We give an exact characterization of the computational complexity of the kCFA hierarchy. For any k \&gt; 0, we prove that the control flow decision problem is complete for deterministic exponential time. This theorem validates empirical observations that such control flow analysis is intractable. It also provides more general insight into the complexity of abstract interpretation.},
	number = {9},
	journal = {SIGPLAN Not.},
	author = {Van Horn, David and Mairson, Harry G.},
	month = sep,
	year = {2008},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {complexity, flow analysis, to-read},
	pages = {275--282},
}

@inproceedings{van_horn_deciding_2008-1,
	address = {New York, NY, USA},
	series = {{ICFP} '08},
	title = {Deciding {KCFA} is {Complete} for {EXPTIME}},
	isbn = {978-1-59593-919-7},
	url = {https://doi.org/10.1145/1411204.1411243},
	doi = {10.1145/1411204.1411243},
	abstract = {We give an exact characterization of the computational complexity of the kCFA hierarchy. For any k \&gt; 0, we prove that the control flow decision problem is complete for deterministic exponential time. This theorem validates empirical observations that such control flow analysis is intractable. It also provides more general insight into the complexity of abstract interpretation.},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Van Horn, David and Mairson, Harry G.},
	year = {2008},
	note = {event-place: Victoria, BC, Canada},
	keywords = {complexity, flow analysis, to-read},
	pages = {275--282},
}

@article{rehof_type-based_nodate,
	title = {Type-{Based} {Flow} {Analysis}: {From} {Polymorphic} {Subtyping} to {CFL}-{Reachability}.},
	abstract = {We present a novel approach to scalable implementation of type-based flow analysis with polymorphic subtyping. Using a new presentation of polymorphic subtyping with instantiation constraints, we are able to apply context-free language (CFL) reachability techniques to type-based flow analysis. We develop a CFL-based algorithm for computing flow information in time O(n3), where n is the size of the typed program. The algorithm substantially improves upon the best previously known algorithm for flow analysis based on polymorphic subtyping with complexity O(n8 ). Our technique also yields the first demand-driven algorithm for polymorphic subtype-based flow-computation. It works directly on higher-order programs with structured data of finite type (unbounded data structures are incorporated via finite approximations), supports context-sensitive, global flow summarization and includes polymorphic recursion.},
	language = {en},
	author = {Rehof, Jakob},
	keywords = {to-read},
	file = {Rehof - Type-Based Flow Analysis From Polymorphic Subtypi.pdf:/Users/timwhiting/Zotero/storage/I25WRPRM/Rehof - Type-Based Flow Analysis From Polymorphic Subtypi.pdf:application/pdf},
}

@article{dunfield_bidirectional_2022,
	title = {Bidirectional {Typing}},
	volume = {54},
	issn = {0360-0300, 1557-7341},
	url = {http://arxiv.org/abs/1908.05839},
	doi = {10.1145/3450952},
	abstract = {Bidirectional typing combines two modes of typing: type checking, which checks that a program satisfies a known type, and type synthesis, which determines a type from the program. Using checking enables bidirectional typing to support features for which inference is undecidable; using synthesis enables bidirectional typing to avoid the large annotation burden of explicitly typed languages. In addition, bidirectional typing improves error locality. We highlight the design principles that underlie bidirectional type systems, survey the development of bidirectional typing from the prehistoric period before Pierce and Turner's local type inference to the present day, and provide guidance for future investigations.},
	language = {en},
	number = {5},
	urldate = {2024-02-06},
	journal = {ACM Computing Surveys},
	author = {Dunfield, Jana and Krishnaswami, Neel},
	month = jun,
	year = {2022},
	note = {arXiv:1908.05839 [cs]},
	keywords = {Computer Science - Programming Languages, Computer Science - Logic in Computer Science, to-read},
	pages = {1--38},
	file = {Dunfield and Krishnaswami - 2022 - Bidirectional Typing.pdf:/Users/timwhiting/Zotero/storage/XQWQDKZ3/Dunfield and Krishnaswami - 2022 - Bidirectional Typing.pdf:application/pdf},
}

@article{vytiniotis_boxy_nodate,
	title = {Boxy {Types}: {Inference} for {Higher}-{Rank} {Types} and {Impredicativity}},
	abstract = {Languages with rich type systems are beginning to employ a blend of type inference and type checking, so that the type inference engine is guided by programmer-supplied type annotations. In this paper we show, for the ﬁrst time, how to combine the virtues of two well-established ideas: uniﬁcation-based inference, and bidirectional propagation of type annotations. The result is a type system that conservatively extends Hindley-Milner, and yet supports both higher-rank types and impredicativity.},
	language = {en},
	author = {Vytiniotis, Dimitrios and Weirich, Stephanie and Jones, Simon Peyton},
	keywords = {to-read},
	file = {Vytiniotis et al. - Boxy Types Inference for Higher-Rank Types and Im.pdf:/Users/timwhiting/Zotero/storage/SBA4B9KH/Vytiniotis et al. - Boxy Types Inference for Higher-Rank Types and Im.pdf:application/pdf},
}

@article{odersky_colored_nodate,
	title = {Colored {Local} {Type} {Inference}},
	abstract = {We present a type system for a language based on F≤, which allows certain type annotations to be elided in actual programs. Local type inference determines types by a combination of type propagation and local constraint solving, rather than by global constraint solving. We reﬁne the previously existing local type inference system of Pierce and Turner[PT98] by allowing partial type information to be propagated. This is expressed by coloring types to indicate propagation directions. Propagating partial type information allows us to omit type annotations for the visitor pattern, the analogue of pattern matching in languages without sum types.},
	language = {en},
	author = {Odersky, Martin and Zenger, Christoph and Zenger, Matthias},
	keywords = {to-read},
	file = {Odersky et al. - Colored Local Type Inference.pdf:/Users/timwhiting/Zotero/storage/NZCC2N96/Odersky et al. - Colored Local Type Inference.pdf:application/pdf},
}

@inproceedings{odersky_putting_1996,
	address = {St. Petersburg Beach, Florida, United States},
	title = {Putting type annotations to work},
	isbn = {978-0-89791-769-8},
	url = {http://portal.acm.org/citation.cfm?doid=237721.237729},
	doi = {10.1145/237721.237729},
	language = {en},
	urldate = {2024-02-06},
	booktitle = {Proceedings of the 23rd {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages  - {POPL} '96},
	publisher = {ACM Press},
	author = {Odersky, Martin and Läufer, Konstantin},
	year = {1996},
	keywords = {to-read},
	pages = {54--67},
	file = {Odersky and Läufer - 1996 - Putting type annotations to work.pdf:/Users/timwhiting/Zotero/storage/UYZT6KTQ/Odersky and Läufer - 1996 - Putting type annotations to work.pdf:application/pdf},
}

@article{jones_practical_2007,
	title = {Practical type inference for arbitrary-rank types},
	volume = {17},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796806006034/type/journal_article},
	doi = {10.1017/S0956796806006034},
	abstract = {Haskell’s popularity has driven the need for ever more expressive type system features, most of which threaten the decidability and practicality of Damas-Milner type inference. One such feature is the ability to write functions with higher-rank types—that is, functions that take polymorphic functions as their arguments.},
	language = {en},
	number = {1},
	urldate = {2024-02-06},
	journal = {Journal of Functional Programming},
	author = {Jones, Simon Peyton and Vytiniotis, Dimitrios and Weirich, Stephanie and Shields, Mark},
	month = jan,
	year = {2007},
	keywords = {to-read},
	pages = {1--82},
	file = {Jones et al. - 2007 - Practical type inference for arbitrary-rank types.pdf:/Users/timwhiting/Zotero/storage/68DPRYBE/Jones et al. - 2007 - Practical type inference for arbitrary-rank types.pdf:application/pdf},
}

@article{bhanuka_getting_2023,
	title = {Getting into the {Flow}: {Towards} {Better} {Type} {Error} {Messages} for {Constraint}-{Based} {Type} {Inference}},
	volume = {7},
	issn = {2475-1421},
	shorttitle = {Getting into the {Flow}},
	url = {https://dl.acm.org/doi/10.1145/3622812},
	doi = {10.1145/3622812},
	abstract = {ISHAN BHANUKA, HKUST, Hong Kong, China LIONEL PARREAUX, HKUST, Hong Kong, China DAVID BINDER, University of Tübingen, Germany JONATHAN IMMANUEL BRACHTHÄUSER, University of Tübingen, Germany Creating good type error messages for constraint-based type inference systems is diﬃcult. Typical type error messages reﬂect implementation details of the underlying constraint-solving algorithms rather than the speciﬁc factors leading to type mismatches. We propose using subtyping constraints that capture data ﬂow to classify and explain type errors. Our algorithm explains type errors as faulty data ﬂows, which programmers are already used to reasoning about, and illustrates these data ﬂows as sequences of relevant program locations. We show that our ideas and algorithm are not limited to languages with subtyping, as they can be readily integrated with Hindley-Milner type inference. In addition to these core contributions, we present the results of a user study to evaluate the quality of our messages compared to other implementations. While the quantitative evaluation does not show that ﬂow-based messages improve the localization or understanding of the causes of type errors, the qualitative evaluation suggests a real need and demand for ﬂow-based messages. CCS Concepts: • Software and its engineering → General programming languages; • Theory of computation → Program analysis; Type theory; • Human-centered computing → Human computer interaction (HCI).},
	language = {en},
	number = {OOPSLA2},
	urldate = {2024-02-06},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Bhanuka, Ishan and Parreaux, Lionel and Binder, David and Brachthäuser, Jonathan Immanuel},
	month = oct,
	year = {2023},
	keywords = {to-read},
	pages = {431--459},
	file = {Bhanuka et al. - 2023 - Getting into the Flow Towards Better Type Error M.pdf:/Users/timwhiting/Zotero/storage/KVPNPFPN/Bhanuka et al. - 2023 - Getting into the Flow Towards Better Type Error M.pdf:application/pdf},
}

@article{heeren_generalizing_nodate,
	title = {Generalizing {Hindley}-{Milner} {Type} {Inference} {Algorithms}},
	abstract = {Type inferencing according to the standard algorithms W and M often yields uninformative error messages. Many times, this is a consequence of a bias inherent in the algorithms. The method developed here is to ﬁrst collect constraints from the program, and to solve these afterwards, possibly under the inﬂuence of a heuristic. We show the soundness and completeness of our algorithm. The algorithms W and M turn out to be deterministic instances of our method, giving the correctness for W and M with respect to the Hindley-Milner typing rules for free. We also show that our algorithm is more ﬂexible, because it naturally allows the generation of multiple messages.},
	language = {en},
	author = {Heeren, Bastiaan and Hage, Jurriaan and Swierstra, Doaitse},
	keywords = {to-read},
	file = {Heeren et al. - Generalizing Hindley-Milner Type Inference Algorit.pdf:/Users/timwhiting/Zotero/storage/R8N852SR/Heeren et al. - Generalizing Hindley-Milner Type Inference Algorit.pdf:application/pdf},
}

@article{leijen_hmf_nodate,
	title = {{HMF}: {Simple} {Type} {Inference} for {First}-{Class} {Polymorphism}},
	abstract = {HMF is a conservative extension of Hindley-Milner type inference with ﬁrst-class polymorphism. In contrast to other proposals, HML uses regular System F types and has a simple type inference algorithm that is just a small extension of the usual Damas-Milner algorithm W. Given the relative simplicity and expressive power, we feel that HMF can be an attractive type system in practice. There is a reference implementation of the type system available online together with a technical report containing proofs (Leijen 2007a,b).},
	language = {en},
	author = {Leijen, Daan},
	keywords = {to-read},
	file = {Leijen - HMF Simple Type Inference for First-Class Polymor.pdf:/Users/timwhiting/Zotero/storage/7W4IGNXS/Leijen - HMF Simple Type Inference for First-Class Polymor.pdf:application/pdf},
}

@article{parreaux_when_2024,
	title = {When {Subtyping} {Constraints} {Liberate}: {A} {Novel} {Type} {Inference} {Approach} for {First}-{Class} {Polymorphism}},
	volume = {8},
	issn = {2475-1421},
	shorttitle = {When {Subtyping} {Constraints} {Liberate}},
	url = {https://dl.acm.org/doi/10.1145/3632890},
	doi = {10.1145/3632890},
	abstract = {Type inference in the presence of first-class or “impredicative” second-order polymorphism à la System F has been an active research area for several decades, with original works dating back to the end of the 80s. Yet, until now many basic problems remain open, such as how to type check expressions like (𝜆𝑥. (𝑥 123, 𝑥 True)) id reliably. We show that a type inference approach based on multi-bounded polymorphism, a form of implicit polymorphic subtyping with multiple lower and upper bounds, can help us resolve most of these problems in a uniquely simple and regular way. We define F
              \{≤\}
              , a declarative type system derived from the existing theory of implicit coercions by Cretin and Rémy (LICS 2014), and we introduce SuperF, a novel algorithm to infer polymorphic multi-bounded F
              \{≤\}
              types while checking user type annotations written in the syntax of System F. We use a recursion-avoiding heuristic to guarantee termination of type inference at the cost of rejecting some valid programs, which thankfully rarely triggers in practice. We show that SuperF is vastly more powerful than all first-class-polymorphic type inference systems proposed so far, significantly advancing the state of the art in type inference for general-purpose programming languages.},
	language = {en},
	number = {POPL},
	urldate = {2024-02-06},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Parreaux, Lionel and Boruch-Gruszecki, Aleksander and Fan, Andong and Chau, Chun Yin},
	month = jan,
	year = {2024},
	keywords = {to-read},
	pages = {1418--1450},
	file = {Parreaux et al. - 2024 - When Subtyping Constraints Liberate A Novel Type .pdf:/Users/timwhiting/Zotero/storage/NRPGE5BJ/Parreaux et al. - 2024 - When Subtyping Constraints Liberate A Novel Type .pdf:application/pdf},
}

@article{lorenzen_functional_nodate,
	title = {The {Functional} {Essence} of {Imperative} {Binary} {Search} {Trees}},
	language = {en},
	author = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter and Lindley, Sam},
	file = {Lorenzen et al. - The Functional Essence of Imperative Binary Search.pdf:/Users/timwhiting/Zotero/storage/E9JTSLEK/Lorenzen et al. - The Functional Essence of Imperative Binary Search.pdf:application/pdf},
}

@article{leijen_tail_2023,
	title = {Tail {Recursion} {Modulo} {Context}: {An} {Equational} {Approach}},
	volume = {7},
	issn = {2475-1421},
	shorttitle = {Tail {Recursion} {Modulo} {Context}},
	url = {https://dl.acm.org/doi/10.1145/3571233},
	doi = {10.1145/3571233},
	abstract = {The tail-recursion modulo
              cons
              transformation can rewrite functions that are not quite tail-recursive into a tail-recursive form that can be executed efficiently. In this article we generalize tail recursion modulo
              cons
              (TRMc) to modulo
              contexts
              (TRMC), and calculate a general TRMC algorithm from its specification. We can instantiate our general algorithm by providing an implementation of application and composition on abstract contexts, and showing that our
              context
              laws\_ hold. We provide some known instantiations of TRMC, namely modulo
              evaluation contexts
              (CPS), and
              associative operations
              , and further instantiantions not so commonly associated with TRMC, such as
              defunctionalized
              evaluation contexts,
              monoids
              ,
              semirings
              ,
              exponents
              , and
              cons products
              . We study the modulo
              cons
              instantiation in particular and prove that an instantiation using Minamide’s hole calculus is sound. We also calculate a second instantiation in terms of the Perceus heap semantics to precisely reason about the soundness of in-place update. While all previous approaches to TRMc fail in the presence of non-linear control (for example induced by call/cc, shift/reset or algebraic effect handlers), we can elegantly extend the heap semantics to a hybrid approach which dynamically adapts to non-linear control flow. We have a full implementation of hybrid TRMc in the Koka language and our benchmark shows the TRMc transformed functions are always as fast or faster than using manual alternatives.},
	language = {en},
	number = {POPL},
	urldate = {2024-02-27},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Leijen, Daan and Lorenzen, Anton},
	month = jan,
	year = {2023},
	keywords = {to-read},
	pages = {1152--1181},
	file = {Leijen and Lorenzen - 2023 - Tail Recursion Modulo Context An Equational Appro.pdf:/Users/timwhiting/Zotero/storage/JPXQGIDL/Leijen and Lorenzen - 2023 - Tail Recursion Modulo Context An Equational Appro.pdf:application/pdf},
}

@article{bracevac_graph_2023,
	title = {Graph {IRs} for {Impure} {Higher}-{Order} {Languages}: {Making} {Aggressive} {Optimizations} {Affordable} with {Precise} {Effect} {Dependencies}},
	volume = {7},
	issn = {2475-1421},
	shorttitle = {Graph {IRs} for {Impure} {Higher}-{Order} {Languages}},
	url = {https://dl.acm.org/doi/10.1145/3622813},
	doi = {10.1145/3622813},
	abstract = {Graph-based intermediate representations (IRs) are widely used for powerful compiler optimizations, either interprocedurally in pure functional languages, or intraprocedurally in imperative languages. Yet so far, no suitable graph IR exists for aggressive global optimizations in languages with both effects and higher-order functions: aliasing and indirect control transfers make it difficult to maintain sufficiently granular dependency information for optimizations to be effective. To close this long-standing gap, we propose a novel typed graph IR combining a notion of reachability types with an expressive effect system to compute precise and granular effect dependencies at an affordable cost while supporting local reasoning and separate compilation. Our high-level graph IR imposes lexical structure to represent structured control flow and nesting, enabling aggressive and yet inexpensive code motion and other optimizations for impure higher-order programs. We formalize the new graph IR based on a λ-calculus with a reachability type-and-effect system along with a specification of various optimizations. We present performance case studies for tensor loop fusion, CUDA kernel fusion, symbolic execution of LLVM IR, and SQL query compilation in the Scala LMS compiler framework using the new graph IR. We observe significant speedups of up to 21
              x
              .},
	language = {en},
	number = {OOPSLA2},
	urldate = {2024-03-09},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Bračevac, Oliver and Wei, Guannan and Jia, Songlin and Abeysinghe, Supun and Jiang, Yuxuan and Bao, Yuyan and Rompf, Tiark},
	month = oct,
	year = {2023},
	keywords = {to-read},
	pages = {400--430},
	file = {Bračevac et al. - 2023 - Graph IRs for Impure Higher-Order Languages Makin.pdf:/Users/timwhiting/Zotero/storage/SLHD2XVN/Bračevac et al. - 2023 - Graph IRs for Impure Higher-Order Languages Makin.pdf:application/pdf},
}

@article{wu_type-_nodate,
	title = {Type- and {Control}-flow {Analysis} for {System} {Fw}},
	abstract = {Type- and control-ﬂow analysis combines control-ﬂow analysis and type-ﬂow analysis. It improves the approximation given by control-ﬂow analysis by using type-ﬂow information to ﬁlter out abstract values with incompatible types. Type-ﬂow analysis and control-ﬂow analysis are mutually beneﬁcial since the control-ﬂow analysis approximates the -expressions in type applications. Previously, a type- and control-ﬂow analysis for System F has been deﬁned. However, System F only has limited support for polymorphism. System FÊ, a more sophisticated type system, augments System F with type-level functions, thereby introducing abstract type constructors. It enables the use of generic functions that are parameterized by polymorphic data structures. In this work, a new type- and control-ﬂow analysis for System FÊ is deﬁned. This work includes a speciﬁcation-based formulation of the type- and controlﬂow analysis for System FÊ and a proof of the soundness of the analysis. This work presents a ﬂow-graph-based formulation. The soundness of the ﬂow-graph-based formulation is proved by relating to the speciﬁcation-based formulation.},
	language = {en},
	author = {Wu, Dongyu},
	keywords = {to-read},
	file = {Wu - Type- and Control-flow Analysis for System Fw.pdf:/Users/timwhiting/Zotero/storage/4VYZAE3Q/Wu - Type- and Control-flow Analysis for System Fw.pdf:application/pdf},
}

@article{alur_analysis_nodate,
	title = {Analysis of recursive state machines},
	volume = {27},
	language = {en},
	number = {4},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Alur, Rajeev},
	keywords = {to-read},
	file = {Alur - Analysis of recursive state machines.pdf:/Users/timwhiting/Zotero/storage/Z8JLDNP8/Alur - Analysis of recursive state machines.pdf:application/pdf},
}

@misc{nagy_automating_2024,
	title = {Automating {Unrealizability} {Logic}: {Hoare}-style {Proof} {Synthesis} for {Infinite} {Sets} of {Programs}},
	shorttitle = {Automating {Unrealizability} {Logic}},
	url = {http://arxiv.org/abs/2401.13244},
	abstract = {Unrealizability logic (UL) was proposed by Kim et al. as the first Hoare-style proof system for proving properties that hold for an infinite set of programs (defined by a regular tree grammar). The goal of our work is to automate reasoning and proof generation for UL. A key ingredient in UL is the notion of nonterminal summaries-inductive facts that characterize recursive nonterminals in the grammar that defines the set of programs. They are analogous to procedure summaries in Hoare logic. The goal of automating UL led us to reformulate the inference rules-in particular, introducing a unified rule for nonterminal summaries, called the rule of adaptation, which draws inspiration from how procedure summaries are handled in Hoare logic. In the same way that verification conditions can be used to synthesize loop invariants for Hoare logic proofs, our reformulation of UL reduces the problem of synthesizing a nonterminal summary to a Syntax-Guided Synthesis problem. We implement Wuldo, the first checker and synthesizer for UL. Wuldo can express proofs beyond the reach of existing tools, including proofs that establish how infinitely many programs behave on infinitely many inputs, and in some cases Wuldo can even synthesize the needed nonterminal summaries.},
	language = {en},
	urldate = {2024-03-21},
	publisher = {arXiv},
	author = {Nagy, Shaan and Kim, Jinwoo and D'Antoni, Loris and Reps, Thomas},
	month = jan,
	year = {2024},
	note = {arXiv:2401.13244 [cs]},
	keywords = {Computer Science - Programming Languages, to-read},
	file = {Nagy et al. - 2024 - Automating Unrealizability Logic Hoare-style Proo.pdf:/Users/timwhiting/Zotero/storage/UC999GNQ/Nagy et al. - 2024 - Automating Unrealizability Logic Hoare-style Proo.pdf:application/pdf},
}

@inproceedings{breck_templates_2020,
	address = {London UK},
	title = {Templates and recurrences: better together},
	isbn = {978-1-4503-7613-6},
	shorttitle = {Templates and recurrences},
	url = {https://dl.acm.org/doi/10.1145/3385412.3386035},
	doi = {10.1145/3385412.3386035},
	abstract = {This paper is the confluence of two streams of ideas in the literature on generating numerical invariants, namely: (1) template-based methods, and (2) recurrence-based methods. A template-based method begins with a template that contains unknown quantities, and finds invariants that match the template by extracting and solving constraints on the unknowns. A disadvantage of template-based methods is that they require fixing the set of terms that may appear in an invariant in advance. This disadvantage is particularly prominent for non-linear invariant generation, because the user must supply maximum degrees on polynomials, bases for exponents, etc.},
	language = {en},
	urldate = {2024-03-21},
	booktitle = {Proceedings of the 41st {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Breck, Jason and Cyphert, John and Kincaid, Zachary and Reps, Thomas},
	month = jun,
	year = {2020},
	keywords = {to-read},
	pages = {688--702},
	file = {Breck et al. - 2020 - Templates and recurrences better together.pdf:/Users/timwhiting/Zotero/storage/IZHNCZYH/Breck et al. - 2020 - Templates and recurrences better together.pdf:application/pdf},
}

@inproceedings{kincaid_compositional_2017,
	address = {Barcelona Spain},
	title = {Compositional recurrence analysis revisited},
	isbn = {978-1-4503-4988-8},
	url = {https://dl.acm.org/doi/10.1145/3062341.3062373},
	doi = {10.1145/3062341.3062373},
	abstract = {Compositional recurrence analysis (CRA) is a static-analysis method based on a combination of symbolic analysis and abstract interpretation. This paper addresses the problem of creating a context-sensitive interprocedural version of CRA that handles recursive procedures. The problem is non-trivial because there is an “impedance mismatch” between CRA, which relies on analysis techniques based on regular languages (i.e., Tarjan’s path-expression method), and the context-free-language underpinnings of contextsensitive analysis.},
	language = {en},
	urldate = {2024-03-21},
	booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Kincaid, Zachary and Breck, Jason and Boroujeni, Ashkan Forouhi and Reps, Thomas},
	month = jun,
	year = {2017},
	keywords = {to-read},
	pages = {248--262},
	file = {Full Text:/Users/timwhiting/Zotero/storage/96G34ZYI/Kincaid et al. - 2017 - Compositional recurrence analysis revisited.pdf:application/pdf},
}

@incollection{silva_algebraic_2021,
	address = {Cham},
	title = {Algebraic {Program} {Analysis}},
	volume = {12759},
	isbn = {978-3-030-81684-1 978-3-030-81685-8},
	url = {https://link.springer.com/10.1007/978-3-030-81685-8_3},
	abstract = {This paper is a tutorial on algebraic program analysis. It explains the foundations of algebraic program analysis, its strengths and limitations, and gives examples of algebraic program analyses for numerical invariant generation and termination analysis.},
	language = {en},
	urldate = {2024-03-21},
	booktitle = {Computer {Aided} {Verification}},
	publisher = {Springer International Publishing},
	author = {Kincaid, Zachary and Reps, Thomas and Cyphert, John},
	editor = {Silva, Alexandra and Leino, K. Rustan M.},
	year = {2021},
	doi = {10.1007/978-3-030-81685-8_3},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {to-read},
	pages = {46--83},
	file = {Full Text:/Users/timwhiting/Zotero/storage/6SJIJXQ4/Kincaid et al. - 2021 - Algebraic Program Analysis.pdf:application/pdf},
}

@article{xie_effect_2020-1,
	title = {Effect handlers, evidently},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3408981},
	doi = {10.1145/3408981},
	abstract = {Algebraic effect handlers are a powerful way to incorporate effects in a programming language. Sometimes perhaps even \_too\_ powerful. In this article we define a restriction of general effect handlers with \_scoped resumptions\_. We argue one can still express all important effects, while improving reasoning about effect handlers. Using the newly gained guarantees, we define a sound and coherent evidence translation for effect handlers, which directly passes the handlers as evidence to each operation. We prove full soundness and coherence of the translation into plain lambda calculus. The evidence in turn enables efficient implementations of effect operations; in particular, we show we can execute tail-resumptive operations \_in place\_ (without needing to capture the evaluation context), and how we can replace the runtime search for a handler by indexing with a constant offset.},
	language = {en},
	number = {ICFP},
	urldate = {2024-03-21},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Xie, Ningning and Brachthäuser, Jonathan Immanuel and Hillerström, Daniel and Schuster, Philipp and Leijen, Daan},
	month = aug,
	year = {2020},
	keywords = {to-read},
	pages = {1--29},
	file = {Xie et al. - 2020 - Effect handlers, evidently.pdf:/Users/timwhiting/Zotero/storage/66PFYG4K/Xie et al. - 2020 - Effect handlers, evidently.pdf:application/pdf},
}

@inproceedings{brachthauser_effekt_2017,
	address = {Vancouver BC Canada},
	title = {Effekt: extensible algebraic effects in {Scala} (short paper)},
	isbn = {978-1-4503-5529-2},
	shorttitle = {Effekt},
	url = {https://dl.acm.org/doi/10.1145/3136000.3136007},
	doi = {10.1145/3136000.3136007},
	abstract = {Algebraic effects are an interesting way to structure effectful programs and offer new modularity properties. We present the Scala library Effekt, which is implemented in terms of a monad for multi-prompt delimited continuations and centered around capability passing. This makes the newly proposed feature of implicit function types a perfect fit for the syntax of our library. Basing the library design on capability passing and a polymorphic embedding of effect handlers furthermore opens up interesting dimensions of extensibility. Preliminary benchmarks comparing Effekt with an established library suggest significant speedups.},
	language = {en},
	urldate = {2024-03-22},
	booktitle = {Proceedings of the 8th {ACM} {SIGPLAN} {International} {Symposium} on {Scala}},
	publisher = {ACM},
	author = {Brachthäuser, Jonathan Immanuel and Schuster, Philipp},
	month = oct,
	year = {2017},
	keywords = {to-read},
	pages = {67--72},
}

@article{darais_constructive_2019,
	title = {Constructive {Galois} {Connections}},
	volume = {29},
	issn = {0956-7968, 1469-7653},
	url = {http://arxiv.org/abs/1807.08711},
	doi = {10.1017/S0956796819000066},
	abstract = {Galois connections are a foundational tool for structuring abstraction in semantics and their use lies at the heart of the theory of abstract interpretation. Yet, mechanization of Galois connections using proof assistants remains limited to restricted modes of use, preventing their general application in mechanized metatheory and certified programming. This paper presents constructive Galois connections, a variant of Galois connections that is effective both on paper and in proof assistants; is complete with respect to a large subset of classical Galois connections; and enables more general reasoning principles, including the “calculational” style advocated by Cousot. To design constructive Galois connections we identify a restricted mode of use of classical ones which is both general and amenable to mechanization in dependently-typed functional programming languages. Crucial to our metatheory is the addition of monadic structure to Galois connections to control a “specification effect.” Effectful calculations may reason classically, while pure calculations have extractable computational content. Explicitly moving between the worlds of specification and implementation is enabled by our metatheory. To validate our approach, we provide two case studies in mechanizing existing proofs from the literature: the first uses calculational abstract interpretation to design a static analyzer; the second forms a semantic basis for gradual typing. Both mechanized proofs closely follow their original paper-and-pencil counterparts, employ reasoning principles not captured by previous mechanization approaches, support the extraction of verified algorithms, and are novel.},
	language = {en},
	urldate = {2024-05-07},
	journal = {Journal of Functional Programming},
	author = {Darais, David and Van Horn, David},
	year = {2019},
	note = {arXiv:1807.08711 [cs]},
	keywords = {Computer Science - Programming Languages},
	pages = {e11},
	file = {Darais and Van Horn - 2019 - Constructive Galois Connections.pdf:/Users/timwhiting/Zotero/storage/HH9BXYBV/Darais and Van Horn - 2019 - Constructive Galois Connections.pdf:application/pdf},
}

@article{sergey_monadic_nodate,
	title = {Monadic abstract interpreters},
	abstract = {Recent developments in the systematic construction of abstract interpreters hinted at the possibility of a broad uniﬁcation of concepts in static analysis. We deliver that uniﬁcation by showing context-sensitivity, polyvariance, ﬂow-sensitivity, reachabilitypruning, heap-cloning and cardinality-bounding to be independent of any particular semantics. Monads become the unifying agent between these concepts and between semantics. For instance, by plugging the same “context-insensitivity monad” into a monadicallyparameterized semantics for Java or for the lambda calculus, it yields the expected context-insensitive analysis.},
	language = {en},
	author = {Sergey, Ilya and Devriese, Dominique and Might, Matthew and Midtgaard, Jan and Darais, David and Clarke, Dave and Piessens, Frank},
	keywords = {to-read},
	file = {Sergey et al. - Monadic abstract interpreters.pdf:/Users/timwhiting/Zotero/storage/LLMZ6GK2/Sergey et al. - Monadic abstract interpreters.pdf:application/pdf},
}

@article{danvy_defunctionalized_nodate,
	title = {Defunctionalized interpreters for programming languages},
	abstract = {This document illustrates how functional implementations of formal semantics (structural operational semantics, reduction semantics, small-step and big-step abstract machines, natural semantics, and denotational semantics) can be transformed into each other. These transformations were foreshadowed by Reynolds in “Definitional Interpreters for Higher-Order Programming Languages” for functional implementations of denotational semantics, natural semantics, and big-step abstract machines using closure conversion, CPS transformation, and defunctionalization. Over the last few years, the author and his students have further observed that functional implementations of small-step and of big-step abstract machines are related using fusion by ﬁxed-point promotion and that functional implementations of reduction semantics and of smallstep abstract machines are related using refocusing and transition compression. It furthermore appears that functional implementations of structural operational semantics and of reduction semantics are related as well, also using CPS transformation and defunctionalization. This further relation provides an element of answer to Felleisen’s conjecture that any structural operational semantics can be expressed as a reduction semantics: for deterministic languages, a reduction semantics is a structural operational semantics in continuation style, where the reduction context is a defunctionalized continuation. As the defunctionalized counterpart of the continuation of a one-step reduction function, a reduction context represents the rest of the reduction, just as an evaluation context represents the rest of the evaluation since it is the defunctionalized counterpart of the continuation of an evaluation function.},
	language = {en},
	author = {Danvy, Olivier},
	keywords = {to-read},
	file = {Danvy - Defunctionalized interpreters for programming lang.pdf:/Users/timwhiting/Zotero/storage/X6PDCJRG/Danvy - Defunctionalized interpreters for programming lang.pdf:application/pdf},
}

@article{wei_refunctionalization_2018,
	title = {Refunctionalization of abstract abstract machines: bridging the gap between abstract abstract machines and abstract definitional interpreters (functional pearl)},
	volume = {2},
	issn = {2475-1421},
	shorttitle = {Refunctionalization of abstract abstract machines},
	url = {https://dl.acm.org/doi/10.1145/3236800},
	doi = {10.1145/3236800},
	abstract = {Abstracting abstract machines is a systematic methodology for constructing sound static analyses for higher-order languages, by deriving small-step abstract abstract machines (AAMs) that perform abstract interpretation from abstract machines that perform concrete evaluation. Darais et al. apply the same underlying idea to monadic definitional interpreters, and obtain monadic abstract definitional interpreters (ADIs) that perform abstract interpretation in big-step style using monads. Yet, the relation between small-step abstract abstract machines and big-step abstract definitional interpreters is not well studied.
            In this paper, we explain their functional correspondence and demonstrate how to systematically transform small-step abstract abstract machines into big-step abstract definitional interpreters. Building on known semantic interderivation techniques from the concrete evaluation setting, the transformations include linearization, lightweight fusion, disentanglement, refunctionalization, and the left inverse of the CPS transform. Linearization expresses nondeterministic choice through first-order data types, after which refunctionalization transforms the first-order data types that represent continuations into higher-order functions. The refunctionalized AAM is an abstract interpreter written in continuation-passing style (CPS) with two layers of continuations, which can be converted back to direct style with delimited control operators. Based on the known correspondence between delimited control and monads, we demonstrate that the explicit use of monads in abstract definitional interpreters is optional.
            All transformations properly handle the collecting semantics and nondeterminism of abstract interpretation. Remarkably, we reveal how precise call/return matching in control-flow analysis can be obtained by refunctionalizing a small-step abstract abstract machine with proper caching.},
	language = {en},
	number = {ICFP},
	urldate = {2024-05-07},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Wei, Guannan and Decker, James and Rompf, Tiark},
	month = jul,
	year = {2018},
	keywords = {to-read},
	pages = {1--28},
	file = {Wei et al. - 2018 - Refunctionalization of abstract abstract machines.pdf:/Users/timwhiting/Zotero/storage/25TYPWR2/Wei et al. - 2018 - Refunctionalization of abstract abstract machines.pdf:application/pdf},
}

@article{hinze_functional_nodate,
	title = {Functional {Pearl}: {Streams} and {Unique} {Fixed} {Points}},
	abstract = {Streams, inﬁnite sequences of elements, live in a coworld: they are given by a coinductive data type, operations on streams are implemented by corecursive programs, and proofs are conducted using coinduction. But there is more to it: suitably restricted, stream equations possess unique solutions, a fact that is not very widely appreciated. We show that this property gives rise to a simple and attractive proof technique essentially bringing equational reasoning to the coworld. In fact, we redevelop the theory of recurrences, ﬁnite calculus and generating functions using streams and stream operators building on the cornerstone of unique solutions. The development is constructive: streams and stream operators are implemented in Haskell, usually by one-liners. The resulting calculus or library, if you wish, is elegant and fun to use. Finally, we rephrase the proof of uniqueness using generalised algebraic data types.},
	language = {en},
	author = {Hinze, Ralf},
	file = {Hinze - Functional Pearl Streams and Unique Fixed Points.pdf:/Users/timwhiting/Zotero/storage/NPNNMCI3/Hinze - Functional Pearl Streams and Unique Fixed Points.pdf:application/pdf},
}

@article{dolan_algebraic_nodate,
	title = {Algebraic {Subtyping}},
	abstract = {Type inference gives programmers the beneﬁt of static, compile-time type checking without the cost of manually specifying types, and has long been a standard feature of functional programming languages. However, it has proven difﬁcult to integrate type inference with subtyping, since the uniﬁcation engine at the core of classical type inference accepts only equations, not subtyping constraints.},
	language = {en},
	author = {Dolan, Stephen},
	file = {Dolan - Algebraic Subtyping.pdf:/Users/timwhiting/Zotero/storage/R46IVVZI/Dolan - Algebraic Subtyping.pdf:application/pdf},
}

@article{gilray_unied_nodate,
	title = {A {Uniﬁed} {Approach} to {Polyvariance} in {Abstract} {Interpretations}},
	abstract = {We describe an approach to exploring polyvariance in abstract interpretations by exposing the allocation of abstract bindings as an analysis parameter. This allocation policy is a method for selecting abstract addresses based on the current state of execution. As addresses are chosen from a ﬁnite set, the allocation policy is responsible for determining the exact degree of merging which occurs between different values at a given point in the analysis. This approach allows us to select any kind of polyvariance desired through the selection of an abstract allocation function. We show how this can be done for an intermediate representation of Scheme, implementing a sound parametric framework for such analyses. We distinguish three disparate interpretations of the k-CFA hierarchy and compare them, instantiating each within our framework and motivating our approach.},
	language = {en},
	journal = {T ime},
	author = {Gilray, Thomas and Might, Matthew},
	file = {Gilray and Might - A Uniﬁed Approach to Polyvariance in Abstract Inte.pdf:/Users/timwhiting/Zotero/storage/7HQU9WCN/Gilray and Might - A Uniﬁed Approach to Polyvariance in Abstract Inte.pdf:application/pdf},
}

@inproceedings{gope_hash_2016,
	address = {Haifa Israel},
	title = {Hash {Map} {Inlining}},
	isbn = {978-1-4503-4121-9},
	url = {https://dl.acm.org/doi/10.1145/2967938.2967949},
	doi = {10.1145/2967938.2967949},
	abstract = {Scripting languages like Javascript and PHP are widely used to implement application logic for dynamically-generated web pages. Their popularity is due in large part to their ﬂexible syntax and dynamic type system, which enable rapid turnaround time for prototyping, releasing, and updating web site features and capabilities. The most common complex data structure in these languages is the hash map, which is used to store key-value pairs. In many cases, hash maps with a ﬁxed set of keys are used in lieu of explicitly deﬁned classes or structures, as would be common in compiled languages like Java or C++. Unfortunately, the runtime overhead of key lookup and value retrieval is quite high, especially relative to the direct offsets that compiled languages can use to access class members. Furthermore, key lookup and value retrieval incur high microarchitectural costs as well, since the paths they execute contain unpredictable branches and many cache accesses, leading to substantially higher numbers of branch mispredicts and cache misses per access to the hashmap. This paper quantiﬁes these overheads, describes a compiler algorithm that discovers common use cases for hash maps and inlines them so that keys are accessed with direct offsets, and reports measured performance beneﬁts on real hardware. A prototype implementation in the HipHop VM infrastructure shows promising performance beneﬁts for a broad array of hash map-intensive server-side PHP applications, up to 37.6\% and averaging 18.81\%, improves SPECWeb throughput by 7.71\% (banking) and 11.71\% (e-commerce).},
	language = {en},
	urldate = {2024-05-07},
	booktitle = {Proceedings of the 2016 {International} {Conference} on {Parallel} {Architectures} and {Compilation}},
	publisher = {ACM},
	author = {Gope, Dibakar and Lipasti, Mikko H.},
	month = sep,
	year = {2016},
	keywords = {to-read},
	pages = {235--246},
	file = {Gope and Lipasti - 2016 - Hash Map Inlining.pdf:/Users/timwhiting/Zotero/storage/EMMMPARN/Gope and Lipasti - 2016 - Hash Map Inlining.pdf:application/pdf},
}

@article{hillerstrom_foundations_nodate,
	title = {Foundations for {Programming} and {Implementing} {Effect} {Handlers}},
	language = {en},
	author = {Hillerström, Daniel},
	keywords = {to-read},
	file = {Hillerström - Foundations for Programming and Implementing Effec.pdf:/Users/timwhiting/Zotero/storage/KZFN8LGX/Hillerström - Foundations for Programming and Implementing Effec.pdf:application/pdf},
}

@article{keidel_sound_2019,
	title = {Sound and reusable components for abstract interpretation},
	volume = {3},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3360602},
	doi = {10.1145/3360602},
	abstract = {Abstract interpretation is a methodology for defining sound static analysis. Yet, building sound static analyses for modern programming languages is difficult, because these static analyses need to combine sophisticated abstractions for values, environments, stores, etc. However, static analyses often tightly couple these abstractions in the implementation, which not only complicates the implementation, but also makes it hard to decide which parts of the analyses can be proven sound independently from each other. Furthermore, this coupling makes it hard to combine soundness lemmas for parts of the analysis to a soundness proof of the complete analysis.
            
              To solve this problem, we propose to construct static analyses modularly from
              reusable analysis components
              . Each analysis component encapsulates a single analysis concern and can be proven sound independently from the analysis where it is used. We base the design of our analysis components on
              arrow transformers
              , which allows us to compose analysis components. This composition preserves soundness, which guarantees that a static analysis is sound, if all its analysis components are sound. This means that analysis developers do not have to worry about soundness as long as they reuse sound analysis components. To evaluate our approach, we developed a library of 13 reusable analysis components in Haskell. We use these components to define a
              k
              -CFA analysis for PCF and an interval and reaching definition analysis for a While language.},
	language = {en},
	number = {OOPSLA},
	urldate = {2024-05-07},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Keidel, Sven and Erdweg, Sebastian},
	month = oct,
	year = {2019},
	keywords = {to-read},
	pages = {1--28},
	file = {Keidel and Erdweg - 2019 - Sound and reusable components for abstract interpr.pdf:/Users/timwhiting/Zotero/storage/U585QFQF/Keidel and Erdweg - 2019 - Sound and reusable components for abstract interpr.pdf:application/pdf},
}

@inproceedings{leijen_structured_2017,
	address = {Oxford UK},
	title = {Structured asynchrony with algebraic effects},
	isbn = {978-1-4503-5183-6},
	url = {https://dl.acm.org/doi/10.1145/3122975.3122977},
	doi = {10.1145/3122975.3122977},
	abstract = {Algebraic effect handlers generalize many control-flow abstractions that are implemented specially in most languages, like exception handling, iterators, or backtracking. In this article, we show how we can implement full support for asynchronous programming as a library using just algebraic effect handlers. The consistent type driven approach also leads naturally to powerful abstractions like block-scoped interleaving, cancellation, and timeout’s that are lacking in other major asynchronous frameworks. We also introduce the concept of ambient state to reason about state that is local to the current strand of asynchronous execution.},
	language = {en},
	urldate = {2024-05-07},
	booktitle = {Proceedings of the 2nd {ACM} {SIGPLAN} {International} {Workshop} on {Type}-{Driven} {Development}},
	publisher = {ACM},
	author = {Leijen, Daan},
	month = sep,
	year = {2017},
	keywords = {to-read},
	pages = {16--29},
	file = {Leijen - 2017 - Structured asynchrony with algebraic effects.pdf:/Users/timwhiting/Zotero/storage/SQ95L55I/Leijen - 2017 - Structured asynchrony with algebraic effects.pdf:application/pdf},
}

@article{owens_structures_nodate,
	title = {From structures and functors to modules and units},
	abstract = {Component programming techniques encourage abstraction and reuse through external linking. Some parts of a program, however, must use concrete, internally speciﬁed references, so a pure component system is not a sufﬁcient mechanism for structuring programs. We present the combination of a static, internally-linked module system and a purely abstractive component system. The latter extends our previous model of typed units to properly account for translucency and sharing. We also show how units and modules can express an SML-style system of structures and functors, and we explore the consequences for recursive structures and functors.},
	language = {en},
	author = {Owens, Scott and Flatt, Matthew},
	keywords = {to-read},
	file = {Owens and Flatt - From structures and functors to modules and units.pdf:/Users/timwhiting/Zotero/storage/H24C578A/Owens and Flatt - From structures and functors to modules and units.pdf:application/pdf},
}

@article{swierstra_data_2008,
	title = {Data types à la carte},
	volume = {18},
	issn = {0956-7968, 1469-7653},
	url = {http://www.journals.cambridge.org/abstract_S0956796808006758},
	doi = {10.1017/S0956796808006758},
	abstract = {This paper describes a technique for assembling both data types and functions from isolated individual components. We also explore how the same technology can be used to combine free monads and, as a result, structure Haskell’s monolithic IO monad.},
	language = {en},
	number = {04},
	urldate = {2024-05-07},
	journal = {Journal of Functional Programming},
	author = {Swierstra, Wouter},
	month = jul,
	year = {2008},
	file = {Swierstra - 2008 - Data types à la carte.pdf:/Users/timwhiting/Zotero/storage/K66433J3/Swierstra - 2008 - Data types à la carte.pdf:application/pdf},
}

@incollection{hutchison_pointer-range_2004,
	address = {Berlin, Heidelberg},
	title = {Pointer-{Range} {Analysis}},
	volume = {3148},
	isbn = {978-3-540-22791-5 978-3-540-27864-1},
	url = {http://link.springer.com/10.1007/978-3-540-27864-1_12},
	abstract = {Array-Range Analysis computes at compile time the range of possible index values for each array-index expression in a program. This information can be used to detect potential out-of-bounds array accesses and to identify non-aliasing array accesses. In a language like C, where arrays can be accessed indirectly via pointers, and where pointer arithmetic is allowed, range analysis must be extended to compute the range of possible values for each pointer dereference.},
	language = {en},
	urldate = {2024-05-07},
	booktitle = {Static {Analysis}},
	publisher = {Springer Berlin Heidelberg},
	author = {Yong, Suan Hsi and Horwitz, Susan},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Giacobazzi, Roberto},
	year = {2004},
	doi = {10.1007/978-3-540-27864-1_12},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {to-read},
	pages = {133--148},
	file = {Yong and Horwitz - 2004 - Pointer-Range Analysis.pdf:/Users/timwhiting/Zotero/storage/P4R6MKQJ/Yong and Horwitz - 2004 - Pointer-Range Analysis.pdf:application/pdf},
}

@article{brachthauser_programming_nodate,
	title = {Programming with {Implicit} {Values}, {Functions}, and {Controlor}, {Implicit} {Functions}: {Dynamic} {Binding} with {Lexical} {ScopingMicrosoft} {Technical} {Report}, {MSR}-{TR}-2019-7, v2.},
	abstract = {We introduce two new language features, called implicit functions and implicit control. Both generalize implicit values which are a typed implementation of dynamic binding. Implicit functions are bound dynamically but evaluated in the lexical scope of their binding. We show how this small generalization from regular implicit values leads to better abstraction. In particular, implicit functions encapsulate (side) effects at the definition site, as opposed to leaking them to the call site. Implicit control further generalizes implicit functions by adding the ability to return into the lexical scope of the binding or to resume to the call-site. We formalize the new features as an extension to Moreau’s calculus of dynamic binding (1998). Unifying all three language features in one framework guarantees that the interaction between implicit values, functions, and control is well-defined. We also show how our semantics correspond to a macro-translation into algebraic effect handlers.},
	language = {en},
	author = {Brachthäuser, Jonathan and Leijen, Daan},
	file = {Brachthäuser and Leijen - Programming with Implicit Values, Functions, and C.pdf:/Users/timwhiting/Zotero/storage/EBU6EIUZ/Brachthäuser and Leijen - Programming with Implicit Values, Functions, and C.pdf:application/pdf},
}

@article{pirog_typed_2019,
	title = {Typed {Equivalence} of {Effect} {Handlers} and {Delimited} {Control}},
	copyright = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/openAccess},
	issn = {1868-8969},
	url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2019.30},
	doi = {10.4230/LIPICS.FSCD.2019.30},
	abstract = {It is folklore that eﬀect handlers and delimited control operators are closely related: recently, this relationship has been proved in an untyped setting for deep handlers and the shift0 delimited control operator. We positively resolve the conjecture that in an appropriately polymorphic type system this relationship can be extended to the level of types, by identifying the necessary forms of polymorphism, thus extending the deﬁnability result to the typed context. In the process, we identify a novel and potentially interesting type system feature for delimited control operators. Moreover, we extend these results to substantiate the folklore connection between shallow handlers and control0 ﬂavour of delimited control, both in an untyped and typed settings.},
	language = {en},
	urldate = {2024-05-08},
	author = {Piróg, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	collaborator = {Geuvers, Herman},
	year = {2019},
	note = {Artwork Size: 16 pages, 500253 bytes
ISBN: 9783959771078
Medium: application/pdf
Publisher: [object Object]
Version Number: 1.0},
	keywords = {algebraic effects, delimited control, macro expressibility, Software and its engineering → Polymorphism, Theory of computation → Control primitives, Theory of computation → Operational semantics, type-and-effect systems},
	pages = {16 pages, 500253 bytes},
	file = {Piróg et al. - 2019 - Typed Equivalence of Effect Handlers and Delimited.pdf:/Users/timwhiting/Zotero/storage/9Z4FMZGH/Piróg et al. - 2019 - Typed Equivalence of Effect Handlers and Delimited.pdf:application/pdf},
}

@inproceedings{kammar_handlers_2013,
	address = {Boston Massachusetts USA},
	title = {Handlers in action},
	isbn = {978-1-4503-2326-0},
	url = {https://dl.acm.org/doi/10.1145/2500365.2500590},
	doi = {10.1145/2500365.2500590},
	abstract = {Plotkin and Pretnar’s handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types.},
	language = {en},
	urldate = {2024-05-09},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {ACM},
	author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
	month = sep,
	year = {2013},
	pages = {145--158},
	file = {Kammar et al. - 2013 - Handlers in action.pdf:/Users/timwhiting/Zotero/storage/B7QNWHC9/Kammar et al. - 2013 - Handlers in action.pdf:application/pdf},
}

@article{saleh_efficient_nodate,
	title = {Efficient {Algebraic} {Effect} {Handlers}},
	language = {en},
	author = {Saleh, Amr Hany},
	keywords = {extra-to-read},
	file = {Saleh - Efficient Algebraic Effect Handlers.pdf:/Users/timwhiting/Zotero/storage/4BDQZBG5/Saleh - Efficient Algebraic Effect Handlers.pdf:application/pdf},
}

@inproceedings{biernacki_reflecting_2021,
	address = {Tallinn Estonia},
	title = {Reflecting {Stacked} {Continuations} in a {Fine}-{Grained} {Direct}-{Style} {Reduction} {Theory}},
	isbn = {978-1-4503-8689-0},
	url = {https://dl.acm.org/doi/10.1145/3479394.3479399},
	doi = {10.1145/3479394.3479399},
	abstract = {The delimited-control operator shift0 has been formally shown to capture the operational semantics of deep handlers for algebraic effects. Its CPS translation generates λ-terms in which continuation composition is not expressed in terms of nested function calls, as is typical of other delimited-control operators, e.g. shift, but with function applications consuming a sequence of continuations one at a time, as if they formed a stack.},
	language = {en},
	urldate = {2024-05-14},
	booktitle = {23rd {International} {Symposium} on {Principles} and {Practice} of {Declarative} {Programming}},
	publisher = {ACM},
	author = {Biernacki, Dariusz and Pyzik, Mateusz and Sieczkowski, Filip},
	month = sep,
	year = {2021},
	keywords = {extra-to-read},
	pages = {1--13},
	file = {Biernacki et al. - 2021 - Reflecting Stacked Continuations in a Fine-Grained.pdf:/Users/timwhiting/Zotero/storage/BZU3HJDH/Biernacki et al. - 2021 - Reflecting Stacked Continuations in a Fine-Grained.pdf:application/pdf},
}

@book{swierstra_trends_2022,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Trends in {Functional} {Programming}: 23rd {International} {Symposium}, {TFP} 2022, {Virtual} {Event}, {March} 17–18, 2022, {Revised} {Selected} {Papers}},
	volume = {13401},
	copyright = {https://www.springernature.com/gp/researchers/text-and-data-mining},
	isbn = {978-3-031-21313-7 978-3-031-21314-4},
	shorttitle = {Trends in {Functional} {Programming}},
	url = {https://link.springer.com/10.1007/978-3-031-21314-4},
	language = {en},
	urldate = {2024-05-14},
	publisher = {Springer International Publishing},
	editor = {Swierstra, Wouter and Wu, Nicolas},
	year = {2022},
	doi = {10.1007/978-3-031-21314-4},
	keywords = {to-read},
	file = {Swierstra and Wu - 2022 - Trends in Functional Programming 23rd Internation.pdf:/Users/timwhiting/Zotero/storage/ZGBD6TF6/Swierstra and Wu - 2022 - Trends in Functional Programming 23rd Internation.pdf:application/pdf},
}

@incollection{swierstra_understanding_2022,
	address = {Cham},
	title = {Understanding {Algebraic} {Effect} {Handlers} via {Delimited} {Control} {Operators}},
	volume = {13401},
	isbn = {978-3-031-21313-7 978-3-031-21314-4},
	url = {https://link.springer.com/10.1007/978-3-031-21314-4_4},
	abstract = {Algebraic eﬀects and handlers are a powerful and convenient abstraction for user-deﬁned eﬀects. We aim to understand eﬀect handlers through the lens of control operators, a similar but more well-studied tool for expressing eﬀects. In this paper, we establish two program transformations and a type system for eﬀect handlers, all by reusing the existing results about control operators and their relationship to eﬀect handlers.},
	language = {en},
	urldate = {2024-05-14},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer International Publishing},
	author = {Cong, Youyou and Asai, Kenichi},
	editor = {Swierstra, Wouter and Wu, Nicolas},
	year = {2022},
	doi = {10.1007/978-3-031-21314-4_4},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {extra-to-read},
	pages = {59--79},
	file = {Cong and Asai - 2022 - Understanding Algebraic Effect Handlers via Delimi.pdf:/Users/timwhiting/Zotero/storage/M64HZQRS/Cong and Asai - 2022 - Understanding Algebraic Effect Handlers via Delimi.pdf:application/pdf},
}

@article{biernacka_generalized_2017,
	title = {Generalized {Refocusing}: {From} {Hybrid} {Strategies} to {Abstract} {Machines}},
	copyright = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/openAccess},
	issn = {1868-8969},
	shorttitle = {Generalized {Refocusing}},
	url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2017.10},
	doi = {10.4230/LIPICS.FSCD.2017.10},
	abstract = {We present a generalization of the refocusing procedure that provides a generic method for deriving an abstract machine from a speciﬁcation of a reduction semantics satisfying simple initial conditions. The proposed generalization is applicable to a class of reduction semantics encoding hybrid strategies as well as uniform strategies handled by the original refocusing method. The resulting machine is proved to correctly trace (i.e., bisimulate in smaller steps) the input reduction semantics. The procedure and the correctness proofs have been formalized in the Coq proof assistant.},
	language = {en},
	urldate = {2024-05-14},
	author = {Biernacka, Malgorzata and Charatonik, Witold and Zielinska, Klara},
	collaborator = {Miller, Dale},
	year = {2017},
	note = {Artwork Size: 17 pages, 507137 bytes
ISBN: 9783959770477
Medium: application/pdf
Publisher: [object Object]},
	keywords = {abstract machines, Coq, extra-to-read, formal verification, reduction semantics},
	pages = {17 pages, 507137 bytes},
	file = {Biernacka et al. - 2017 - Generalized Refocusing From Hybrid Strategies to .pdf:/Users/timwhiting/Zotero/storage/LBQQMP9K/Biernacka et al. - 2017 - Generalized Refocusing From Hybrid Strategies to .pdf:application/pdf},
}

@article{materzok_subtyping_nodate,
	title = {Subtyping delimited continuations},
	abstract = {We present a type system with subtyping for ﬁrst-class delimited continuations that generalizes Danvy and Filinski’s type system for shift and reset by maintaining explicit information about the types of contexts in the metacontext. We exploit this generalization by considering the control operators known as shift0 and reset0 that can access arbitrary contexts in the metacontext. We use subtyping to control the level of information about the metacontext the expression actually requires and in particular to coerce pure expressions into effectful ones. For this type system we prove strong type soundness and termination of evaluation and we present a provably correct type reconstruction algorithm. We also introduce two CPS translations for shift0 and reset0: one targeting the untyped lambda calculus, and another—type-directed—targeting the simply-typed lambda calculus. The latter translation preserves typability and is selective in that it keeps pure expressions in direct style.},
	language = {en},
	author = {Materzok, Marek and Biernacki, Dariusz},
	keywords = {extra-to-read},
	file = {Materzok and Biernacki - Subtyping delimited continuations.pdf:/Users/timwhiting/Zotero/storage/ATYB5AIT/Materzok and Biernacki - Subtyping delimited continuations.pdf:application/pdf},
}

@inproceedings{kammar_handlers_2013-1,
	address = {Boston Massachusetts USA},
	title = {Handlers in action},
	isbn = {978-1-4503-2326-0},
	url = {https://dl.acm.org/doi/10.1145/2500365.2500590},
	doi = {10.1145/2500365.2500590},
	abstract = {Plotkin and Pretnar’s handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types.},
	language = {en},
	urldate = {2024-05-13},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {ACM},
	author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
	month = sep,
	year = {2013},
	pages = {145--158},
	file = {Kammar et al. - 2013 - Handlers in action.pdf:/Users/timwhiting/Zotero/storage/8YENIUE6/Kammar et al. - 2013 - Handlers in action.pdf:application/pdf},
}

@article{hillerstrom_effect_2020,
	title = {Effect handlers via generalised continuations},
	volume = {30},
	copyright = {https://www.cambridge.org/core/terms},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796820000040/type/journal_article},
	doi = {10.1017/S0956796820000040},
	abstract = {Plotkin and Pretnar’s effect handlers offer a versatile abstraction for modular programming with user-deﬁned effects. This paper focuses on foundations for implementing effect handlers, for the three different kinds of effect handlers that have been proposed in the literature: deep, shallow, and parameterised.},
	language = {en},
	urldate = {2024-05-15},
	journal = {Journal of Functional Programming},
	author = {Hillerström, Daniel and Lindley, Sam and Atkey, Robert},
	year = {2020},
	keywords = {extra-to-read},
	pages = {e5},
	file = {Hillerström et al. - 2020 - Effect handlers via generalised continuations.pdf:/Users/timwhiting/Zotero/storage/J8UHRIAK/Hillerström et al. - 2020 - Effect handlers via generalised continuations.pdf:application/pdf},
}

@article{kameyama_axioms_2007,
	title = {Axioms for control operators in the {CPS} hierarchy},
	volume = {20},
	copyright = {http://www.springer.com/tdm},
	issn = {1388-3690, 1573-0557},
	url = {http://link.springer.com/10.1007/s10990-007-9009-x},
	doi = {10.1007/s10990-007-9009-x},
	abstract = {A CPS translation is a syntactic translation of programs, which is useful for describing their operational behavior. By iterating the standard call-by-value CPS translation, Danvy and Filinski discovered the CPS hierarchy and proposed a family of control operators, shift and reset, that make it possible to capture successive delimited continuations in a CPS hierarchy.},
	language = {en},
	number = {4},
	urldate = {2024-05-15},
	journal = {Higher-Order and Symbolic Computation},
	author = {Kameyama, Yukiyoshi},
	month = nov,
	year = {2007},
	keywords = {extra-to-read},
	pages = {339--369},
	file = {Kameyama - 2007 - Axioms for control operators in the CPS hierarchy.pdf:/Users/timwhiting/Zotero/storage/DZIY7DNE/Kameyama - 2007 - Axioms for control operators in the CPS hierarchy.pdf:application/pdf},
}

@article{kameyama_sound_nodate,
	title = {A {Sound} and {Complete} {Axiomatization} of {Delimited} {Continuations}},
	abstract = {The shift and reset operators, proposed by Danvy and Filinski, are powerful control primitives for capturing delimited continuations. Delimited continuation is a similar concept as the standard (unlimited) continuation, but it represents part of the rest of the computation, rather than the whole rest of computation. In the literature, the semantics of shift and reset has been given by a CPS-translation only. This paper gives a direct axiomatization of calculus with shift and reset, namely, we introduce a set of equations, and prove that it is sound and complete with respect to the CPS-translation. We also introduce a calculus with control operators which is as expressive as the calculus with shift and reset, has a sound and complete axiomatization, and is conservative over Sabry and Felleisen’s theory for ﬁrst-class continuations.},
	language = {en},
	author = {Kameyama, Yukiyoshi and Hasegawa, Masahito},
	keywords = {extra-to-read},
	file = {Kameyama and Hasegawa - A Sound and Complete Axiomatization of Delimited C.pdf:/Users/timwhiting/Zotero/storage/35553A4Z/Kameyama and Hasegawa - A Sound and Complete Axiomatization of Delimited C.pdf:application/pdf},
}
